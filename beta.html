<!DOCTYPE html>
<html lang="ja-jp">

<head>
	<script>console.time('load')</script>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport"
		content="width=device-width,initial-scale=1,user-scalable=yes,viewport-fit=cover,interactive-widget=resizes-content">
	<!--iOS standarone時はuser-scalable=no -->
	<meta prefix=”og:http://ogp.me/ns#”>
	<meta property="og:url" content="https://r314.f5.si/" />
	<meta property="og:type" content="website" />
	<meta property="og:title" content="ファイル置き場" />
	<meta property="og:description" content="ファイルをアップロードするところです" />
	<meta property="og:site_name" content="ファイル置き場" />
	<meta property="og:image" content="/src/ico/appicons/icon_512x.png" />
	<link rel="icon" href="/src/ico/appicons/icon_128x.png" />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="preconnect" href="https://cdnjs.cloudflare.com/" crossorigin>
	<link rel="preconnect" href="https://cdn.jsdelivr.net/" crossorigin>
	<link rel="shortcut icon" href="/src/ico/appicons/icon_512x.png">
	<link rel="manifest" href="/src/manifest.json">
	<meta id="themecolor" name="theme-color" content="#f4f4f4">
	<link rel="apple-touch-icon"
		href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAA0lSURBVHhe7d3NcdzWFoVR8U0dDyNwCqpSLg7AubBKKTgCxeMxzbZBiXriT/8A955z91oTYwywsT+AdOvu8cknACDK/7b/AgBBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABLp7fLIdw6f7h8/bERzv25ev29Htfv/z7+3oOn/98dt2BBkEQDBjz2yVAuBEBJBEAIQx+lRSLQBORAAp/A1AiNPwG3/42F4hAdUJgMUZfricCCCBAFiU4YfbiABWJwAWY/hhPyKAlQmARRh+OIYIYFUCoDnDD8cTAaxIADRm+GEcEcBqBEBTxh/GEwGsRAA0ZPxhHhHAKgRAM8Yf5hMBrEAANGL8oQ4RQHcCoAnjD/WIADoTAA0Yf6hLBNCVACjO+EN9IoCOBADADkQA3QiAwjz9Qy8igE4EQFHGH3oSAXQhAAB2JgLoQAAU5Okf+hMBVCcAAA4iAqhMABTj6R/WIgKoSgAAHEwEUJEAKMTTP6xLBFCNAAAYRARQiQAowtM/ZBABVCEAAAYTAVQgAAAmEAHMJgAK8PofMokAZhIAABOJAGYRAACTiQBmEAAABYgARhMAAEWIAEYSAJP5A0DgJRHAKAIAoBgRwAgCAKAgEcDRBABAUSKAIwkAgMJEAEcRAADFiQCOIAAAGhAB7E0AADQhAtiTAABoRASwFwEA0IwIYA8CAKAhEcCtBABAUyKAWwgAgMZEANcSAADNiQCuIQAAFiACuJQAAFiECOASAgBgISKAcwkAgMWIAM4hAAAWJAL4iAAAWJQI4D0CAGBhIoC3CACAxYkAXiMAAAKIAP6fAAAIIQJ4SQAABBEBPBMAAGFEACcCACCQCEAAAIQSAdkEAEAwEZBLAACEEwGZBAAAIiCQAADgXyIgiwAA4DsRkEMAAPATEZBBAADwCxGwPgEAwKtEwNoEAABvEgHrEgAAvEsErEkAAPAhEbAeAQDAWUTAWgQAAGcTAesQAABcRASsQQAAcDER0J8AAOAqIqA3AQDA1URAXwIAgJuIgJ4EAAA3EwH9CAAAdiECehEAAOxGBPQhAADYlQjoQQAAsDsRUJ8AAOAQIqA2AQDAYURAXQIAgEOJgJoEALCEv/74bTuiIhFQjwAAYAgRUIsAAGAYEVCHAABgKBFQgwAAYDgRMJ8AAJbhDwF7EQFzCQAAphEB8wgAAKYSAXMIAGApfg3QkwgYTwAAUIIIGEsAAMvxFqAvETCOAACgFBEwhgAAluQtQG8i4HgCAAACCQBgWd4CwNsEAAAEEgDANPcPn7ej43gLAK8TAAAQSAAAy/MWAH4lAAAgkAAAIngLAD8TAMBUI/4Q8JkIgB8EABBFBMB/BAAQRwSAAAAKGPlrgGcigHQCAIglAkgmAIASZrwFOBEBpBIAQDwRQCIBAJQx6y3AySkChABJBADACyKAFAIAKGXmW4Bn3gaQQAAAvEEIsDIBAJRT4S3AS0KAFQkAgDMJAVYiAICSqr0FeOk5BMQAnd09PtmOmaDyTQ5m+/bl63bUy+9//r0dcQuBdSwBMJkAgPd1jQCozq8AgNJEMhxDAADliQDYnwAAWhABsC8BALQhAmA/AgBoRQTAPgQA0I4IgNsJAKAlEQC3EQBAW6cIEAJwHQEAtCcC4HICAPjF6dv3un0Dn7cBcBkBAPzk5fB3/BpeIQDnEQDAd68NfscIOBEC8D4BAPzrvaHvGgEnQgBe518DnMyNiQrOHfhVfl47Bw3sRQBMJgCY7dIxXPVnVhSQRgBMJgCY6drR83PLCKLsWP4GAELdcnN1Y4b+BAAE2mPARQD0JgAgzJ7DLQKgLwEAQY4YbBEAPQkACHHkUIsA6EcAQIARAy0CoBcBAIsbOcwiAPoQALCwGYMsAqAHAQCLmjnEIgDqEwCwoAoDLAKgNgEAi6k0vCIA6hIAsJCKgysCoCYBAIuoPLQiAOoRALCADgMrAqAWAQDNdRpWEQB1CABorOOgigCoQQBAU52HVATAfAIAGlphQEUAzCUAoJmVhlMEwDwCABpZcTBFAMwhAKCJlYdSBMB4AgAaSBhIEQBjCQAoLmkYRQCMIwCgsMRBFAEwhgCAopKHUATA8QQAFGQAnQM4mgCAYgzfD84FHEcAQCEG71fOCRxDAEARhu5tzg3sTwBAAQbuY84R7EsAwGSG7XzOFexHAMBEBu1yzhnsQwDAJIbses4d3E4AwAQG7HbOIdxGAMBghms/ziVcTwDAQAZrf84pXEcAwCCG6jjOLVxOAMAABup4zjFcRgDAwQzTOM41nE8AwIEM0njOOZxHAMBBDNE8zj18TADAAQzQfK4BvE8AwM4MTx2uBbxNAMCODE49rgm8TgDATgxNXa4N/EoAwA4MTH2uEfxMAMCNDEsfrhX8IADgBgalH9cM/iMA4EqGpC/XDgQAXMWA9Ocakk4AwIUMxzpcS5IJALiAwViPa0oqAQBnMhTrcm1JJADgDAZifa4xaQQAfMAw5HCtSSIA4B0GIY9rTgoBAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEOju8cl2zAT3D5+3I7hN9f9/3c86l/KdDMfyBgAAAgkAAAgkAAAgkAAAgEACAAACCQAACCQAACCQAACAQAIAAAIJAAAIJAAAIJAAAIBAAgAAAgkAAAgkAAAgkAAAgEACAAACCQAACCQAACCQAACAQAIAAAIJAAAIJAAAIJAAAIBAAgAAAgkAAAgkAAAgkAAAgEACAAACCQAACCQAACCQAACAQAIAAAIJAAAIJAAAIJAAAIBAAgAAAgkAAAgkAAAgkAAAgEACAAACCQAACCQAACCQAACAQAIAAAIJAAAIJAAAIJAAAIBAAgAAAgkAAAgkAAAgkAAAgEACAAACCQAACCQAACCQAACAQAIAAAIJAAAIJAAAIJAAAIBAAgAAAgkAAAgkAAAgkAAAgEACAAACCQAACCQAACCQAACAQAIAAAIJAAAIJAAAIJAAAIBAAgAAAgkAAAh09/hkO2aC+4fP2xEAL3378nU74gjeAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAk3378nU7AoBxBAAA5Xg4Op4AAIBAAgAAAgkAAAgkAArwuy4ARhMAAJTioWgMAQAAgQRAEYoXgJEEAABleBgaRwAU4gcfgFEEAAAleAgaSwAU4wMAwAgCAIDpPPyMJwAK8kEA4GgCAICpPPTMIQCK8oEA4EgCAIBpPOzMIwAK88EAVuYeN5cAAIBAAqA4hQysyL1tPgHQgA8KsBL3tBoEQBM+MMAK3MvqEACN+OAAnbmH1SIAmvEBAjpy76pHADTkgwR04p5VkwBoygcK6MC9qi4B0JgPFlCZe1Rtd49PtmMau3/4vB0BzGX4exAACxEBwEyGvxcBsCAhAIxk+HsSAAsTAsCRDH9vAiCAEAD2ZPjXIACCCAHgFoZ/LQIglBgAzmH01yUA+E4UQDZjn0UAAEAg3wQIAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAIAEAAIEEAAAEEgAAEEgAAEAgAQAAgQQAAAQSAAAQSAAAQCABAACBBAAABBIAABBIAABAnE+f/gH0EsbNdsuM9gAAAABJRU5ErkJggg==">
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<title>ファイル置き場</title>
	<meta name="description" content="ファイルとか動画とかいろいろアップロードするところです">
	<style>
		::view-transition-old(*),
		::view-transition-new(*) {
			animation-duration: 0.2s;
		}

		:root {
			overflow: hidden;
			overscroll-behavior: none;
			--black: #000000;
			--white: #ffffff;
			--darkgrey: grey;
			--green: #58b058;
			--blue: #5395ee;
			--red: #df3939;
			--unfocus--text-color: #7f7f7f;
			--safe-area-top: env(safe-area-inset-top, 0px);
			--border-radius: 8px;
			--light-background-primary: #ffffff;
			--light-background-secondary: #f4f4f4;
			--light-accent-color: #58b058;
			--light-background-color: #3a3a3a74;
			--light-text-color: black;
			--light-text-opposite-color: white;
			--light-shadow: rgba(0, 0, 0, 0.1) 0px 4px 6px -1px, rgba(0, 0, 0, 0.06) 0px 2px 4px -1px;
			--dark-background-primary: #161616;
			--dark-background-secondary: #2a2a2a;
			--dark-accent-color: #005a2c;
			--dark-background-color: #000000b0;
			--dark-text-color: white;
			--dark-text-opposite-color: black;
			--dark-shadow: rgba(14, 30, 37, 0.12) 0px 4px 6px -1px, rgba(14, 30, 37, 0.32) 0px 2px 4px -1px;
			--deep-dark-background-primary: #000000;
			--deep-dark-background-secondary: #121212;
			--deep-dark-accent-color: #00360c;
			--deep-dark-text-color: #e6e6e6;
		}

		@media (prefers-color-scheme: light) {
			[data-theme=system] {
				--background-primary: var(--light-background-primary);
				--background-secondary: var(--light-background-secondary);
				--accent-color: var(--light-accent-color);
				--background-color: var(--light-background-color);
				--text-color: var(--light-text-color);
				--text-opposite-color: var(--light-text-opposite-color);
				--shadow: var(--light-shadow);
			}
		}

		@media (prefers-color-scheme: dark) {
			[data-theme=system] {
				--background-primary: var(--dark-background-primary);
				--background-secondary: var(--dark-background-secondary);
				--accent-color: var(--dark-accent-color);
				--background-color: var(--dark-background-color);
				--text-color: var(--dark-text-color);
				--text-opposite-color: var(--dark-text-opposite-color);
				--shadow: var(--dark-shadow);
			}

			.deep-dark[data-theme=system] {
				--background-primary: var(--deep-dark-background-primary);
				--background-secondary: var(--deep-dark-background-secondary);
				--accent-color: var(--deep-dark-accent-color);
				--text-color: var(--deep-dark-text-color);
			}
		}

		[data-theme=light] {
			--background-primary: var(--light-background-primary);
			--background-secondary: var(--light-background-secondary);
			--accent-color: var(--light-accent-color);
			--background-color: var(--light-background-color);
			--text-color: var(--light-text-color);
			--text-opposite-color: var(--light-text-opposite-color);
			--shadow: var(--light-shadow);
		}

		[data-theme=dark] {
			--background-primary: var(--dark-background-primary);
			--background-secondary: var(--dark-background-secondary);
			--accent-color: var(--dark-accent-color);
			--background-color: var(--dark-background-color);
			--text-color: var(--dark-text-color);
			--text-opposite-color: var(--dark-text-opposite-color);
			--shadow: var(--dark-shadow);
		}

		.deep-dark[data-theme=dark] {
			--background-primary: var(--deep-dark-background-primary);
			--background-secondary: var(--deep-dark-background-secondary);
			--accent-color: var(--deep-dark-accent-color);
			--text-color: var(--deep-dark-text-color);
		}

		*,
		*:before,
		*:after {
			-webkit-box-sizing: border-box;
			box-sizing: border-box;
			overscroll-behavior: contain;
			color: var(--text-color);
			stroke: var(--text-color);
		}

		::-webkit-scrollbar {
			width: 8px;
			height: 8px;
		}

		::-webkit-scrollbar-track {
			background-color: var(--background-secondary);
		}

		::-webkit-scrollbar-thumb {
			background-color: var(--darkgrey);
			border-radius: var(--border-radius);
		}

		::-webkit-scrollbar-corner {
			background-color: var(--background-secondary);
		}

		::placeholder {
			user-select: none;
		}

		input[type=text],
		input[type=url],
		input[type=number],
		option,
		select {
			background: var(--background-secondary);
			border-radius: var(--border-radius);
			border: none;
			height: 2.3rem;
			font-size: 1.1rem;
			margin: 5px;
			font-family: 'Noto Sans JP', sans-serif;
			padding: 4px;
		}

		input {
			accent-color: var(--accent-color);
		}

		input.toggleButton {
			position: relative;
			padding-left: 60px;
			cursor: pointer;
			appearance: none;
		}

		input.toggleButton::before,
		input.toggleButton::after {
			content: "";
			display: block;
			position: absolute;
			top: 50%;
			left: 0px;
			transform: translateY(-50%);
			border-radius: 50%;
			transition: 0.2s;
		}

		input.toggleButton::before {
			background-color: var(--darkgrey);
			border-radius: 12px;
			height: 20px;
			width: 40px;
			top: 50%;
			left: 5px;
		}

		input.toggleButton::after {
			background-color: var(--white);
			border-radius: 50%;
			height: 16px;
			width: 16px;
			top: 50%;
			left: 8px;
		}

		input.toggleButton:checked::before {
			background-color: var(--accent-color);
		}

		input.toggleButton:checked::after {
			left: 26px;
		}

		hr {
			width: 100%;
			margin: 2px 0px;
			border: none;
			height: 1px;
			background: var(--darkgrey);
		}

		button {
			font-family: inherit;
			cursor: pointer;
			-webkit-user-select: none;
			user-select: none;
		}

		body {
			padding: 0;
			margin: 0;
			background-color: var(--background-primary);
			height: 100dvh;
			overflow: hidden;
			overscroll-behavior: none;
			font-family: 'Noto Sans JP', sans-serif;
			touch-action: pan-y;
			touch-callout: none;
			-webkit-touch-callout: none;
		}

		header {
			display: flex;
			width: 100vw;
			height: calc(env(safe-area-inset-top) + 3rem);
			font-size: 1.1rem;
			background: var(--background-secondary);
			padding-top: calc(env(safe-area-inset-top) + 8px);
			padding-right: 8px;
			padding-bottom: 8px;
			padding-left: 8px;
			-webkit-user-select: none;
			user-select: none;
			flex-direction: row;
			flex-wrap: nowrap;
			justify-content: space-between;
			align-content: center;
			align-items: center;
			overscroll-behavior: none;
		}

		.icon {
			width: 24px;
			aspect-ratio: 1/1;
			background: var(--text-color);
			border: none;
			-webkit-mask-repeat: no-repeat;
			mask-repeat: no-repeat;
			-webkit-mask-image: var(--src);
			mask-image: var(--src);
		}

		.header-iconText {
			display: flex;
			gap: 12px;
			padding: 8px;
			align-items: stretch;
		}

		.header-nav {
			display: flex;
			height: 100%;
			padding: 4px;
			gap: 8px;
			flex-grow: 1;
			justify-content: flex-end;
		}

		.appTitle {
			cursor: pointer;
		}

		main {
			display: flex;
			overflow: hidden;
			flex-grow: 1;
			overscroll-behavior: none;
			background: var(--background-secondary);
		}

		.control {
			width: 100%;
			height: 10vh;
			margin-top: 5rem;
			display: flex;
			flex-wrap: nowrap;
			flex-direction: row;
			justify-content: center;
			align-items: center;
		}

		button.upload>svg {
			height: 2rem;
			stroke: var(--white);
		}

		button.upload {
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			align-content: center;
			align-items: center;
			font-size: 1.2rem;
			border: none;
			border-radius: var(--border-radius);
			margin: 5px;
			background: var(--accent-color);
			color: var(--white);
			cursor: pointer;
			user-select: none;
			font-weight: bold;
		}

		.body {
			display: flex;
			flex-direction: column;
			background: var(--background-primary);
			overflow: hidden;
			height: 100%;
			overscroll-behavior: none;
		}

		.main {
			flex-grow: 1;
			overflow: hidden;
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			scroll-snap-type: x mandatory;
			overscroll-behavior-y: contain;
			border-top-left-radius: var(--border-radius);
			background: var(--background-primary);
		}

		.main>div {
			flex: 0 0 100%;
			scroll-snap-align: start;
			height: 100%;
		}

		.sidebar {
			width: auto;
			height: 100%;
			display: flex;
			white-space: nowrap;
			align-content: space-between;
			transition: width 0.2s cubic-bezier(0.25, 1, 0.5, 1);
			will-change: width, height;
			display: grid;
			background: var(--background-secondary);
			padding: 8px;
			gap: 12px;
			position: relative;
			overscroll-behavior: none;
		}

		.sidebar_icons {
			display: flex;
			flex-direction: column;
			gap: 8px;
			width: 100%;
			overflow: hidden;
		}

		.fileControl {
			width: 70%;
			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
			align-content: center;
			align-items: center;
			justify-content: space-between;
		}

		.modalbg {
			background-color: var(--background-color);
			width: 100vw;
			height: 100%;
			z-index: 100;
			position: fixed;
			top: 0px;
			left: 0px;
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			align-content: center;
			justify-content: center;
			align-items: center;
			pointer-events: all;
		}

		.modal {
			background: var(--background-primary);
			width: 60%;
			height: 70%;
			min-height: 400px;
			min-width: 768px;
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
			align-content: center;
			justify-content: flex-start;
			align-items: center;
			position: relative;
			border-radius: var(--border-radius);
			transition: width 0.2s, height 0.2s;
			will-change: width, height;
		}

		.modal.fullscreen {
			width: 100%;
			height: 100%;
			border-radius: 0px;
		}

		.modalbg:has(.fullscreen) {
			margin-top: env(safe-area-inset-top, 0px);
		}

		.modal.fullscreen .modal__header {
			border-radius: 0px;
		}

		.modal__header {
			width: 100%;
			height: 2rem;
			background-color: var(--background-secondary);
			color: var(--text-color);
			display: flex;
			padding: 0 5px;
			box-sizing: border-box;
			font-size: 1.2rem;
			-webkit-user-select: none;
			user-select: none;
			border-radius: var(--border-radius) var(--border-radius) 0 0;
			justify-content: space-between;
			flex-wrap: nowrap;
			flex-direction: row;
			align-items: center;
		}

		.modal__buttons {
			display: flex;
			flex-direction: row;
			align-items: center;
			height: 100%;
			flex-wrap: nowrap;
			justify-content: flex-end;
			gap: 5px;
			padding: 1px;
		}

		.modal__title {
			text-overflow: ellipsis;
			overflow: hidden;
			white-space: nowrap;
		}

		.modal__body {
			width: 100%;
			height: calc(100% - 2rem);
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
			padding: 16px;
			box-sizing: border-box;
			color: var(--black);
			overflow-y: overlay;
		}

		div#drop-zone {
			display: flex;
			width: 100%;
			padding: 5px;
			height: 130px;
			align-items: center;
			flex-direction: column;
			border: 5px dashed var(--text-opposite-color);
			box-sizing: border-box;
			justify-content: center;
			user-select: none;
			-webkit-user-select: none;
		}

		.uploadBtns {
			display: flex;
			margin-top: 30px;
			flex-wrap: nowrap;
			flex-direction: row;
			align-items: center;
			justify-content: flex-start;
		}

		.flexCenter {
			width: 100%;
			margin: 20px 0px;
			display: flex;
			flex-wrap: nowrap;
			flex-direction: row;
			justify-content: center;
		}

		.files,
		.uploadfiles {
			display: grid;
			gap: 8px;
			justify-content: center;
			grid-template-columns: repeat(auto-fill, 300px);
			overflow-y: auto;
			padding: 64px 16px;
		}

		.fileChild {
			width: 300px;
			box-sizing: border-box;
			height: 210px;
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
			max-width: 350px;
			cursor: pointer;
		}

		.fileico {
			height: 85%;
			display: flex;
			flex-direction: column;
			align-content: center;
			justify-content: center;
			align-items: center;
			user-select: none;
			background: var(--background-secondary);
			border-radius: var(--border-radius);
		}

		.fileIcon {
			width: 48px;
			height: 48px;
			background: var(--text-color);
		}

		.filemenu {
			height: 24px;
			aspect-ratio: 1/1;
			background: var(--text-color);
			-webkit-mask-image: url(/src/ico/menu.svg);
			mask-image: url(/src/ico/menu.svg);
			-webkit-mask-repeat: no-repeat;
			mask-repeat: no-repeat;
		}

		.fileinfo {
			-background-primary-space: nowrap;
			text-overflow: ellipsis;
			overflow: hidden;
			user-select: none;
			-webkit-user-select: none;
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			align-content: center;

			justify-content: space-between;
		}

		.ViewControl {
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			align-content: center;
			align-items: center;
		}

		.reloadFile {
			display: flex;
			align-items: center;
			justify-content: center;
			background: var(--background-secondary);
			border-radius: 100vh;
			padding: 3px;
			width: 2rem;
			height: 2rem;
			transition: background 0.2s;
			cursor: pointer;
			margin-left: 5px;
			border: none;
		}

		.reloadFile:hover {
			background: #bebebe;
		}

		.contextmenu {
			display: flex;
			position: absolute;
			top: 0;
			left: 0;
			background: var(--background-primary);
			padding: 6px 10px;
			border-radius: var(--border-radius);
			box-shadow: var(--shadow);
			-webkit-user-select: none;
			user-select: none;
			flex-direction: column;
			min-width: 200px;
			z-index: 101;
			-webkit-app-region: no-drag;
		}

		.contextmenuChild {
			margin: 1px 0px;
			font-size: 0.9rem;
			cursor: pointer;
			padding: 5px 0px;
			border: none;
			background: none;
			text-align: left;
			font-family: inherit;
			position: relative;
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			align-items: center;
			justify-content: space-between;
			gap: 4px;
			white-space: nowrap;
		}

		.contextmenuChild:disabled {
			--text-color: var(--unfocus--text-color);
			cursor: not-allowed;
		}

		a#FileDownload {
			color: var(--black);
			text-decoration: none;
		}

		.contextmenuChild:hover {
			background: var(--background-secondary);
		}

		.massage__ico {
			font-size: 220%;
			font-weight: bold;
			font-family: monospace;
		}

		.check_mark {
			width: 1rem;
			height: 0.3rem;
			transform: rotate(-45deg) translateY(-4px);
			border-bottom: solid 7px var(--green);
			border-left: solid 7px var(--green);
			margin: 5px;
		}

		.settingChild {
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			justify-content: space-between;
			align-items: center;
			border-radius: var(--border-radius);
			background-color: var(--background-secondary);
			padding: 12px;
			margin: 8px 0px;
			box-sizing: border-box;
			user-select: none;
		}

		.settinglable {
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
		}

		.settinginput {
			display: flex;
		}

		div.settinglable>span:nth-child(2) {
			font-size: 0.8rem;
			color: gray;
		}

		#updateinterval {
			width: 3rem;
		}

		#massageShowTime {
			width: 3rem;
		}

		.uploadfileinfo {
			width: 90%;
			background: var(--background-secondary);
			border-radius: var(--border-radius);
			padding: 5px 15px;
			box-sizing: border-box;
			font-size: 0.95rem;
			margin: 5px 0px;
		}

		.filename {
			width: 100%;
			text-overflow: ellipsis;
			white-space: nowrap;
			overflow: hidden;
			-webkit-user-select: none;
			user-select: none;
		}

		.filePreview {
			height: 100%;
			user-select: text;
			-webkit-user-select: text;
			object-fit: contain;
			width: 100%;
			margin: 0px;
		}

		.modal__body.file__body {
			display: block;
			overflow-y: auto;
		}

		img.files\.preview,
		video.files\.preview {
			width: 95%;
			height: 95%;
			object-fit: contain;
			border: none;
			outline: none;
		}

		.files[data-layout=wide] .fileChild {
			width: 100%;
			max-width: unset;
			height: 60px;
			display: flex;
			flex-direction: row;
			align-items: center;
			box-shadow: none;
			border: none;
			margin: 2px;
		}

		.files[data-layout=wide] .fileChild>.fileico {
			border: none;
			aspect-ratio: 1/1;
			background: none;
			backdrop-filter: none;
		}

		.files[data-layout=wide] .fileChild>.fileinfo {
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			justify-content: space-evenly;
			width: 100%;
		}

		.files[data-layout=wide] .fileChild>img.files\.preview {
			width: 50px;
		}

		.fileshowchange {
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			align-items: center;
			border-left: 1px gray;
		}

		.fileviewcontrolbtn {
			width: 2rem;
			height: 2rem;
			background: url(/src/ico/usually.png);
			background-size: contain;
			margin: 0px 3px;
		}

		.fileviewcontrolbtn {
			width: 2rem;
			height: 2rem;
			margin: 0px 3px;
			cursor: pointer;
			border: none;
		}

		.fileviewcontrolbtn:first-child {
			background: url(/src/ico/usually.png);
			background-size: contain;
		}

		.fileviewcontrolbtn:nth-child(2) {
			background: url(/src/ico/wide.png);
			background-size: contain;
		}

		.filedownloada {
			text-decoration: none;
			color: var(--black);
		}

		.filepreview.pdf {
			height: 100%;
		}

		.modal__body.file__body.pdf {
			padding: 0;
			flex-direction: unset;
			flex-wrap: unset;
		}

		input.url:invalid {
			border-color: var(--red);
		}

		input.url:valid {
			border-color: var(--green);
		}

		input.url {
			width: 100%;
			height: 2.2rem;
			font-size: 1.3rem;
			border: none;
			border-bottom: solid 2px;
			outline: none;
			padding: 10px;
			margin: 0px;
		}

		.QRcode {
			width: 256px;
			height: 256px;
			display: flex;
			justify-content: center;
			background: white;
			padding: 10px;
			border-radius: var(--border-radius);
			box-sizing: content-box;
		}

		.toast {
			width: 100%;
			height: 60px;
			background: var(--background-primary);
			box-shadow: var(--shadow);
			border-radius: var(--border-radius);
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 0.9rem;
			-webkit-user-select: none;
			user-select: none;
			cursor: pointer;
			margin: 5px 0px;
			transition: transform 0.2s;
		}

		.toastArea {
			position: fixed;
			right: 18px;
			top: 2rem;
			width: 25%;
			background: transparent;
			z-index: 10;
			min-width: 200px;
		}

		.toast:active {
			transform: scale(0.98);
		}

		div.progressfile {
			display: flex;
			flex-direction: row;
			align-items: center;
		}

		.fileChild.uploadfile {
			position: relative;
		}

		.progressfile progress {
			position: absolute;
			bottom: -3px;
			left: 0;
			height: 13px;
			width: 100%;
			accent-color: var(--blue);
		}

		button:nth-child(1)>svg>path {
			stroke: var(--white);
		}

		.fileAddMethod {
			display: flex;
			flex-direction: row;
			background: var(--background-secondary);
			border: none;
			margin: 8px 0px;
			padding: 12px;
			gap: 12px;
			border-radius: var(--border-radius);
			cursor: pointer;
			font-family: inherit;
			align-items: center;
		}

		.fileAddMethodTitle {
			font-size: 1.2rem;
		}

		.fileAddMethodIcon {
			width: 2rem;
			aspect-ratio: 1/1;
			display: flex;
		}

		.fileAddMethodText {
			display: flex;
			flex-direction: column;
			align-items: flex-start;
		}

		button.actionButton {
			height: 100%;
			aspect-ratio: 1/1;
			background: var(--text-color);
			cursor: pointer;
			border: none;
			-webkit-mask-repeat: no-repeat;
			mask-repeat: no-repeat;
			-webkit-app-region: no-drag;
		}

		button.actionButton:focus-visible {
			transform: scale(1.2);
		}

		.headerleft {
			display: flex;
			flex-wrap: nowrap;
			flex-direction: row;
			transform: translateX(-5px);
		}

		body.using-background-image {
			--background-secondary-transparent: #ffffff50
		}

		body.using-background-image .fileico,
		body.using-background-image .reloadFile,
		body.using-background-image::-webkit-scrollbar-track {
			-webkit-backdrop-filter: blur(5px);
			backdrop-filter: blur(5px);
			background: var(--background-secondary-transparent);
		}

		body.using-background-image .filename {
			text-shadow: 0 0 5px var(--text-opposite-color);
		}

		body.using-background-image .body::before {
			position: fixed;
			top: 0;
			left: 0;
			z-index: -1;
			width: 100vw;
			height: 100%;
			background-attachment: fixed;
			background-size: cover;
			background-position: center;
			content: "";
		}

		body.using-background-image .body {
			background: unset;
		}

		.imageSelector {
			width: 100px;
			aspect-ratio: 1/1;
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
			align-items: center;
			background-size: cover;
			justify-content: center;
			background: var(--background-secondary);
			margin: 5px;
			border-radius: var(--border-radius);
			box-shadow: var(--shadow);
			cursor: pointer;
			user-select: none;
			border: none;
		}

		.imageSelect {
			display: flex;
			justify-content: center;
			flex-wrap: wrap;
		}

		.imageSelector>svg {
			width: 50px;
		}

		.directoryBackButton {
			-webkit-mask-image: url(/src/ico/arrow_up.svg);
			mask-image: url(/src/ico/arrow_up.svg);
			-webkit-mask-repeat: no-repeat;
			mask-repeat: no-repeat;
			height: 80%;
			aspect-ratio: 1/1;
			cursor: pointer;
			flex-grow: 0;
			background: var(--text-color);
		}

		.directoryBars {
			height: 40px;
			display: flex;
			align-items: center;
			flex-wrap: nowrap;
			justify-content: center;
			width: 80%;
			gap: 10px;
			margin: 10px 0px;
		}

		input.directory {
			font-family: inherit;
			font-size: 1rem;
			width: 0%;
			flex-grow: 2;
			margin: 0px;
		}

		.fileChild[draggable=true] {
			-webkit-user-drag: element;
			-webkit-user-select: all;
			user-select: all;
		}

		.directoryViewer {
			position: relative;
			display: flex;
			flex-direction: column;
			align-items: stretch;
			flex-wrap: nowrap;
		}

		.toolbar {
			display: flex;
			flex-direction: row;
			align-items: center;
			padding: 12px;
			gap: 12px;
			border-bottom: solid 1px var(--background-secondary);
		}

		button.toolbar-button {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: space-evenly;
		}

		.fileAddFloatButton {
			display: flex;
			width: 64px;
			height: 64px;
			position: absolute;
			bottom: 16px;
			right: 16px;
			padding: 0;
			background: var(--background-secondary);
			border: none;
			border-radius: 100vh;
			box-shadow: var(--shadow);
			justify-content: center;
			align-items: center;
		}

		.fileAddFloatButtonIcon {
			width: 60%;
		}

		.directory {
			display: flex;
			gap: 12px;
			height: 100%;
			font-size: 1.1rem;
			flex-grow: 2;
			background: var(--background-secondary);
			border-radius: var(--border-radius);
			padding: 4px;
		}

		button.toolbar-button:not(.icon) {
			height: 100%;
			border: none;
			background-color: var(--background-secondary);
			gap: 12px;
			padding: 4px 12px;
			border-radius: var(--border-radius);
		}

		input.search {
			flex-grow: 1;
			margin: 0px;
			width: 0%;
			transition: width 0.2s;
			height: 100%;
		}

		input.search:focus-visible {
			width: 40%;
		}

		.QRcodeRapper {
			display: flex;
			justify-content: center;
		}

		button.directoryBackButton:focus-visible {
			transform: scale(1.5);
		}

		.sideButton_icon {
			height: 100%;
			aspect-ratio: 1/1;
			background: var(--text-color);
		}

		button.sideButton {
			border: none;
			background: none;
			font-size: 16px;
			cursor: pointer;
			white-space: nowrap;
			display: flex;
			flex-direction: row;
			flex-wrap: nowrap;
			align-items: center;
			justify-content: space-between;
			gap: 8px;
			-webkit-appearance: none;
			appearance: none;
			padding: 8px;
		}

		.sideButton_detail button.sideButton {
			padding: 4px;
		}

		.sideButton_textIconRapper {
			display: flex;
			gap: 12px;
			flex-direction: row;
			flex-wrap: nowrap;
			align-items: center;
		}

		div.sideButton_icon {
			width: 24px;
			aspect-ratio: 1/1;
			background: var(--text-color);
			cursor: pointer;
			border: none;
			-webkit-mask-repeat: no-repeat;
			mask-repeat: no-repeat;
		}

		.sidebar_dragArea {
			height: 100%;
			width: 12px;
			position: absolute;
			right: -6px;
			top: 0;
			cursor: w-resize;
		}

		.sideButton_detail {
			margin-left: 16px;
			display: flex;
			gap: 4px;
			flex-direction: column;
			overflow-x: hidden;
		}

		button.sideButton_icon.sideButton_expandButton {
			transition: rotate 0.2s;
		}

		.sidebar[data-state=close] .sideButton_text,
		.sidebar[data-state=close] .sideButton_expandButton,
		.sidebar[data-state=close] .sidebar_dragArea,
		.sidebar[data-state=close] .sideButton_detail {
			display: none;
		}

		.sidebar[data-state=close] button.sideButton {
			width: unset;
		}

		.contextIcon {
			height: 20px;
			aspect-ratio: 1/1;
			background: var(--text-color);
			-webkit-mask-repeat: no-repeat;
			mask-repeat: no-repeat;
		}

		.version {
			position: fixed;
			right: 12px;
			bottom: 4px;
			font-size: 0.8rem;
			opacity: 0.5;
		}

		.hljs-ln-n:before {
			color: var(--darkgrey);
		}

		table.hljs-ln>tbody>tr:hover {
			outline: solid 2px var(--darkgrey);
		}

		table.hljs-ln>tbody>tr:hover .hljs-ln-n:before {
			color: unset;
		}

		.hljs-ln .hljs-ln-numbers {
			padding-right: 8px;
		}

		@media (display-mode: window-controls-overlay) {
			:root {
				--safe-area-top: calc(env(safe-area-inset-top, 0px) + 3rem)
			}

			header {
				-webkit-app-region: drag;
				app-region: drag;
				transform: translateX(env(titlebar-area-x, 0px));
				padding-top: 0px;
				padding-right: calc(100% - env(titlebar-area-width, 0px));
				padding-bottom: 0px;
				padding-left: 8px;
			}

			.header-nav {
				height: env(titlebar-area-height, 100%);
				padding: 6px 0px;
				margin-bottom: calc(3rem - env(titlebar-area-height, 0px));
			}

			body.blur header {
				--text-color: var(--unfocus--text-color);
			}

			header .sideButton_icon {
				-webkit-app-region: no-drag;
				app-region: no-drag;
			}

			.header-iconText {
				font-size: 0.9rem;
			}

			.modalbg {
				margin-top: var(--safe-area-top) !important;
				height: calc(100% - var(--safe-area-top));
			}
		}

		@media screen and (max-width: 768px) {
			.sp-invisible {
				display: none !important;
			}

			.modal {
				transition: none;
				width: 100%;
				height: 100%;
				min-height: unset;
				max-height: unset;
				max-width: unset;
				min-width: unset;
			}

			.modal__header {
				border-radius: 0px;
			}

			main {
				flex-direction: column-reverse;
			}

			.sidebar {
				width: 100% !important;
				height: max-content;
				display: flex;
				transition: none;
				padding: 4px;
				padding-bottom: calc(env(safe-area-inset-bottom) + 4px);
			}

			.sidebar_icons {
				flex-direction: row;
				justify-content: space-evenly;
				flex-grow: 1;
				width: unset;
				height: max-content;
			}

			button.sideButton {
				padding: 0px;
			}

			.sidebar_dragArea,
			.sideButton_detail,
			.sideButton_expandButton,
			#sidebar_control_button {
				display: none;
			}

			.sideButton_textIconRapper {
				display: flex;
				flex-direction: column;
				gap: 0px;
				font-size: 0.7rem;
			}

			.sideButton_text {
				display: block !important;
			}
		}

		.fileico .vsc-controller {
			display: none !important;
		}
	</style>
</head>
<!--https://qiita.com/junya/items/3ff380878f26ca447f85 -->

<body data-theme="light" ontouchstart="">
	<div id="templates">
		<template id="filepreviewtemplate">
			<div class="file modal">
				<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 filepreviewclose" fill="none" viewBox="0 0 24 24"
					stroke="currentColor" stroke-width="2">
					<path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path>
				</svg>
				<div class="modal__header file__title"></div>
				<div class="modal__body file__body">
				</div>
			</div>
		</template>
		<template id="fileicotemplate">
			<div class="fileico"></div>
			<div class="fileinfo">
				<div class="filename"></div>
				<div class="filemenu"></div>
			</div>
		</template>
		<template id="uploadfileicotemplate">
			<div class="fileico">
				<img src="" class="files.preview" alt="" loading="lazy">
			</div>
			<div class="fileinfo">
				<div class="filename"></div>
				<div class="progressfile">
					<progress max="1" value="0"></progress>
				</div>
				<div class="filemenu"></div>
			</div>
		</template>
		<template id="modalTemplate">
			<div class="modalbg">
				<div class="modal">
					<div class="modal__header">
						<div class="modal__title"></div>
						<div class="modal__buttons"></div>
					</div>
					<div class="modal__body"></div>
				</div>
			</div>
		</template>
		<template id="YoutubeTemplate">
			<form id="fileform" onsubmit="return false;">
				<label style="margin-top:20px;display: block;">URL:</label>
				<input type="url" style="width: 100%;" autocomplete="off" data-name="youtubeId"
					placeholder="https://youtube.com/watch?v=...">
				<span style="color: var(--red);">地域限定、非公開、Youtube PremiumコンテンツなどはDL不可</span>
				<label style="margin-top:20px;display: block;">ファイルの名前(拡張子不要):</label>
				<input type="text" style="width: 100%;" autocomplete="off" data-name="filename" placeholder="example">
				<label style="margin-top:20px;display: block;">フォーマット</label>
				<select class="downloadType">
					<option value="audioonly">音声のみ</option>
					<option value="both">動画、音声両方</option>
				</select></p>
				<div style="display:flex;justify-content:center;">
					<div class="uploadfileinfo">
						<span>動画情報</span>
						<div>タイトル:<span data-name="videoTitle">-</span></div>
						<div>秒数:<span data-name="videoLengthSeconds">-</span></div>
						<div>チャンネル名:<span data-name="videoOwnerChannelName">-</span></div>
						<iframe width="256" height="144" src="https://www.youtube.com/embed/"
							title="YouTube video player" data-name="youtubePreview" frameborder="0"
							allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
							allowfullscreen></iframe>
					</div>
				</div>
				<div class="uploadBtns">
					<button class="upload youtubeforumreset" data-name="FormReturn"
						style="background-color: var(--blue);padding: 5px 30px;width: 50%;display: unset;">戻る</button>
					<button class="upload youtubeforumadd" data-name="youtubeAddBtn"
						style="width:50%;padding: 5px 30px;display: unset;">追加</button>
				</div>
			</form>
		</template>
		<template id="fileUploadTemplate">
			<form id="fileform" onsubmit="return false;">
				<label style="display: block;">アップロードするファイル:</label>
				<div id="drop-zone" title="ファイルをドロップしてファイルを選択してください" data-name="dropZone">
					<span>ここにファイルをドロップ</span><span>または</span>
					<input type="file" multiple data-name="fileSelect">
				</div>
				<label style="margin-top:20px;display: block;">アップロードするときのファイルの名前:</label>
				<input type="text" style="width: 100%;" autocomplete="off" data-name="filename"
					placeholder="example.txt">
				<div style="display:flex;justify-content:center;">
					<div class="uploadfileinfo">
						<span>選択したファイルの情報</span>
						<div>名前:<span data-name="fileName">-</span></div>
						<div>サイズ:<span data-name="fileSize">-</span></div>
						<div>時間(推定):<span data-name="fileTime">-</span></div>
					</div>
				</div>
				<div class="uploadBtns">
					<button class="upload" data-name="FormReturn"
						style="background-color: var(--blue);padding: 5px 30px;width: 50%;display: unset;">戻る</button>
					<button class="upload" data-name="uploadBtn"
						style="width:50%;padding: 5px 30px;display: unset;">アップロード</button>
				</div>
			</form>
		</template>
		<template id="fileAddTemplate">
			<button data-name="folder" class="fileAddMethod">
				<div class="fileAddMethodIcon">
					<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
						stroke="currentColor" class="w-6 h-6">
						<path stroke-linecap="round" stroke-linejoin="round"
							d="M12 10.5v6m3-3H9m4.06-7.19l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
					</svg>
				</div>
				<div class="fileAddMethodText">
					<div class="fileAddMethodTitle">フォルダーを追加</div>
					<div class="fileAddMethodDescription">フォルダーを作成します</div>
				</div>
			</button>
			<button data-name="fromLocal" class="fileAddMethod">
				<div class="fileAddMethodIcon">
					<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
						stroke="currentColor" class="w-6 h-6">
						<path stroke-linecap="round" stroke-linejoin="round"
							d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
					</svg>
				</div>
				<div class="fileAddMethodText">
					<div class="fileAddMethodTitle">ファイルをアップロード</div>
					<div class="fileAddMethodDescription">ファイルを送信して追加</div>
				</div>
			</button>
			<button data-name="fromYoutube" class="fileAddMethod">
				<div class="fileAddMethodIcon">
					<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
						stroke="currentColor" class="w-6 h-6">
						<path stroke-linecap="round" stroke-linejoin="round"
							d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" />
					</svg>
				</div>
				<div class="fileAddMethodText">
					<div class="fileAddMethodTitle">Youtubeから追加</div>
					<div class="fileAddMethodDescription">YoutubeのURLから追加</div>
				</div>
			</button>
		</template>
		<template id="AddbackgroundTemplate">
			<input type="file" accept=".jpg, .png, .jpeg" style="display: none;" data-name="file">
			<label style="display: block;">画像を選択:</label>
			<div data-name="imageSelect" class="imageSelect">
				<button data-name="imageAdd" data-default class="imageSelector">
					<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 upload_icon_svg" fill="none"
						viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
						<path stroke-linecap="round" stroke-linejoin="round"
							d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
					</svg>
					<span>追加</span>
				</button>
				<button data-name="imageClear" data-default class="imageSelector">
					<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
						stroke="currentColor" class="w-6 h-6">
						<path stroke-linecap="round" stroke-linejoin="round"
							d="M9.75 9.75l4.5 4.5m0-4.5l-4.5 4.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
					</svg>
					<span>背景をクリア</span>
				</button>
			</div>
		</template>
		<template id="filesharetemplate">
			<div class="QRcodeRapper">
				<div class="QRcode"></div>
			</div>
			<label>URL:</label>
			<input type="url" class="url">
		</template>
		<template id="directoryViewTemplate">
			<div class="toolbar">
				<button class="toolbar-button back icon" style="--src:url(/src/ico/arrow-up.svg)"
					title="前のディレクトリに戻る"></button>
				<button class="toolbar-button reload icon" style="--src:url(/src/ico/reload.svg)"
					title="再読み込み"></button>
				<div class="directory"></div>
				<input type="text" class="search" placeholder="このフォルダ内のファイルを検索">
			</div>
			<div class="files"></div>
			<button class="fileAddFloatButton">
				<div class="fileAddFloatButtonIcon icon" style="--src:url(/src/ico/plus.svg)"></div>
			</button>
		</template>
		<template id="settingSimpleTemplate">
			<div class="settingChild">
				<div class="settinglable">
					<span class="settingName"></span>
					<span class="settingDescription"></span>
				</div>
				<div class="settinginput">
					<input>
				</div>
			</div>
		</template>
	</div>
	<div class="body">
		<header>
			<div class="header-iconText">
				<div class="sideButton_icon" id="sidebar_control_button"
					style="mask-image: url('/src/ico/bars3.svg');-webkit-mask-image: url('/src/ico/bars3.svg');">
				</div>
				<span class="appTitle" data-click-timestamp="0" data-click-count="0">ファイル置き場</span>
			</div>
			<div class="header-nav">
				<button class="sideButton_icon" id="setting_button" title="設定"
					style="mask-image: url('/src/ico/setting.svg');-webkit-mask-image: url('/src/ico/setting.svg');"></button>
			</div>
		</header>
		<main>
			<div class="sidebar" data-state="close" data-width="250" style="width: 56px;">
				<div class="sidebar_icons"></div>
				<div class="sidebar_dragArea"></div>
			</div>
			<div class="main">
				<div class="directoryView"></div>
				<div class="addedFilesView"></div>
				<div class="favoriteFilesView"></div>
			</div>
		</main>
	</div>
	<div class="version" style="display: none;" inert>3.0.0(β)</div>
	<div class="toastArea"></div>
	<textarea id="textarea" style="position:absolute;left: -9999px;display: none;" readonly></textarea>
	<a href="#" download="" id="jsdownload" title="download" tabindex="-1"></a>
	<script>
		/*
		function class は先頭大文字
		変数 は先頭小文字
		単語の区切りは大文字
		function の定義は アロー関数
		*/

		"use strict";
		const ErrorHandle = (message) => {
			const body = {
				content: message
			};
			const blob = new Blob([JSON.stringify(body)], {
				type: 'application/json',
			});

			navigator.sendBeacon('/api/error/', blob)
		}

		window.addEventListener('error', (e) => {
			ErrorHandle(`${e.type}: ${e.message}`)
		})

		window.addEventListener("unhandledrejection", (e) => {
			ErrorHandle(`${e.type}: ${e.reason}`)
		});

		const validQueryDomains = new Set([
			'youtube.com',
			'www.youtube.com',
			'm.youtube.com',
			'music.youtube.com',
			'gaming.youtube.com',
			'youtu.be',
		]);
		const idRegex = /^[a-zA-Z0-9-_]{11}$/;
		const validPathDomains = /^https?:\/\/(youtu\.be\/|(www\.)?youtube\.com\/(embed|v|shorts)\/)/;
		const getURLVideoID = link => {
			const parsed = new URL(link.trim());
			let id = parsed.searchParams.get('v');
			if (validPathDomains.test(link.trim()) && !id) {
				const paths = parsed.pathname.split('/');
				id = parsed.host === 'youtu.be' ? paths[1] : paths[2];
			} else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {
				throw Error('Not a YouTube domain');
			}
			if (!id) {
				throw Error(`No video id found: "${link}"`);
			}
			id = id.substring(0, 11);
			if (!idRegex.test(id.trim())) {
				throw TypeError(`Video id (${id}) does not match expected ` +
					`format (${idRegex.toString()})`);
			}
			return id;
		};

		const filePath = {
			GetExtension: path => {
				if (path.includes('.')) {
					return path.split('.').at(-1);
				} else {
					return path.split('/').at(-1);
				}
			},
			GetPath: path => {
				const array = path.split('/');
				array.pop();
				return array.join('/') + '/';
			},
			GetName: path => {
				return path.split('/').at(-1);
			},
			GetNameWithoutExtension: path => {
				const name = path.split('/').at(-1);
				const array = name.split('.');
				array.pop();
				return array.join('.');
			}
		}

		class EventRegister {
			constructor() { this.events = {} }
			On(name, fn) {
				if (this.events[name] === undefined) this.events[name] = new Array()
				this.events[name].push(fn)
			}
			Emit(name, ...arg) {
				if (this.events[name] === undefined) return
				this.events[name].forEach(fn => fn(...arg))
			}
		}

		class FilePath {
			constructor(pathname) { this.pathname = pathname }
			get extension() {
				if (this.pathname.includes('.')) {
					return this.pathname.split('.').at(-1);
				} else {
					return this.pathname.split('/').at(-1);
				}
			}
			get path() {
				const array = this.pathname.split('/');
				array.pop();
				return array.join('/') + '/';
			}
			get name() {
				return this.pathname.split('/').at(-1);
			}
			get nameWithoutExtension() {
				const name = this.pathname.split('/').at(-1);
				const array = name.split('.');
				array.pop();
				return array.join('.');
			}
			get url() {
				return BASE_URL + this.pathname
			}
		}

		class ContextMenu {
			constructor(option) {
				this.option = option
				this.DOM = document.createElement('div')
				this.DOM.classList.add('contextmenu')
				this.option.menuList.forEach(menu => {
					switch (menu.type) {
						case 'line': {
							const menuElement = document.createElement('hr')
							this.DOM.appendChild(menuElement)
							break;
						}
						default: {
							const menuButtonElement = document.createElement('button')
							menuButtonElement.classList.add('contextmenuChild')
							menuButtonElement.innerText = menu.text
							menuButtonElement.addEventListener('click', menu.onClick, { once: true })
							menuButtonElement.addEventListener('hover', menu.onHover, { once: false })
							Object.assign(menuButtonElement.style, menu.style)
							if (menu.submenu) {
								const subContextmenu = new ContextMenu({
									parentElement: menuButtonElement,
									menuList: menu.submenu
								})
								const SubMenuShowHandle = () => {
									subContextmenu.Show()
									const rect = menuButtonElement.getBoundingClientRect()
									subContextmenu.DOM.style.top = '0px'
									subContextmenu.DOM.style.left = rect.width + 'px'
									if (window.innerWidth - rect.right < rect.width) {
										subContextmenu.DOM.style.left = 0 - (rect.width + 20/*padding*/) + 'px';
									}
								}
								const SubMenuHideHandle = () => {
									subContextmenu.Remove()
								}
								menuButtonElement.addEventListener('mouseover', e => {
									if (!(e.target === menuButtonElement)) {
										return
									}
									SubMenuShowHandle()
								})
								menuButtonElement.addEventListener('click', e => {
									if (!(e.target === menuButtonElement)) {
										return SubMenuHideHandle()
									}
									e.stopImmediatePropagation()
									SubMenuShowHandle()
								})
								menuButtonElement.addEventListener('mouseleave', e => {
									if (!(e.target === menuButtonElement)) {
										return
									}
									SubMenuHideHandle()
								})
							}
							if (menu.icon) {
								const iconElement = document.createElement('div')
								iconElement.classList.add('contextIcon')
								iconElement.style.webkitMaskImage = `url(${menu.icon})`
								iconElement.style.maskImage = `url(${menu.icon})`
								menuButtonElement.appendChild(iconElement)
							}
							if (menu.disable === true) {
								menuButtonElement.disabled = true
							}
							this.DOM.appendChild(menuButtonElement)
							break;
						}
					}
				});
			}
			Show() {
				(this.option?.parentElement ?? document.body).appendChild(this.DOM)
				this.DOM.animate(
					[
						{ opacity: 0 },
						{ opacity: 1 }
					], {
					duration: 100, //再生時間（ミリ秒）
					easing: 'linear', //イージング
				})
				this.DOM.firstChild.focus()
				this.SetPosition(this.option.x ?? mousePosition.x, this.option.y ?? mousePosition.y)
				setTimeout(() => {
					document.addEventListener('click', e => this.Remove(), { once: true })
					window.addEventListener('blur', e => this.Remove(), { once: true })
					document.addEventListener('contextmenu', e => this.Remove(), { once: true })
					document.addEventListener('mousewheel', e => this.Remove(), { passive: false, once: true });
				}, 10);
				return this
			}
			SetPosition(x, y) {
				this.DOM.style.top = y + 'px',
					this.DOM.style.left = x + 'px'
				if (window.innerHeight - y < this.DOM.offsetHeight) {
					this.DOM.style.top = y - this.DOM.offsetHeight + 'px';
				}
				if (window.innerWidth - x < this.DOM.offsetWidth) {
					this.DOM.style.left = x - this.DOM.offsetWidth + 'px';
				}
				return this
			}
			Remove() {
				this.DOM.remove();
				return this;
			}
		}

		class Modal extends EventRegister {
			constructor(option) {
				super()
				this.option = option ?? []
				this.clone = document.querySelector('#modalTemplate').content.cloneNode(true);
				this.title = this.clone.querySelector('.modal__title');
				this.buttons = this.clone.querySelector('.modal__buttons');
				this.body = this.clone.querySelector('.modal__body');
				this.modal = this.clone.querySelector('.modal');
			}
			SetTitle(name) {
				this.title.innerText = name;
				this.name = name
				return this
			}
			SetContent(selector) {
				// selector.content からクローンしてbodyに追加
				const contentTemplate = selector.content.cloneNode(true);
				this.body.appendChild(contentTemplate)
				return this
			}
			Open(callback = () => { }) {
				(this.option.buttons ?? [{
					iconPath: '/src/ico/x.svg',
					onClick: () => this.Close()
				}]).forEach(buttonSetting => {
					const button = document.createElement('button')
					button.classList.add('actionButton')
					button.addEventListener('click', () => buttonSetting.onClick(this))
					button.style.webkitMaskImage = `url(${buttonSetting.iconPath})`
					button.style.maskImage = `url(${buttonSetting.iconPath})`
					this.buttons.appendChild(button)
				})
				// bodyにmodal追加
				document.body.appendChild(this.clone);
				this.modal.parentElement.animate(
					[
						{ opacity: 0 },
						{ opacity: 1 }
					], {
					duration: 100, //再生時間（ミリ秒）
					easing: 'linear', //イージング
				})
				// Escで消す
				const escEvent = document.addEventListener('keydown', e => {
					if (e.key !== 'Escape') return
					this.Close()
					removeEventListener('keydown', escEvent)
				})
				// callbackを実行
				callback(this.body);
				return this
			}
			FullScreen() {
				this.modal.classList.add('fullscreen')
				return this
			}
			ExitFullScreen() {
				this.modal.classList.remove('fullscreen')
				return this
			}
			ToggleFullscreen() {
				this.modal.classList.toggle('fullscreen')
				return this
			}
			Close() {
				const anime = this.modal.parentElement.animate(
					[
						{ opacity: 1 },
						{ opacity: 0 }
					], {
					duration: 100, //再生時間（ミリ秒）
					easing: 'linear', //イージング
				})
				anime.addEventListener('finish', () => this.modal.parentElement.remove());
				this.Emit('close')
				return this;
			}
		}

		class Toast {
			#removed = false
			constructor(string, option) {
				this.string = string;
				this.color = option.color ?? 'green';
				this.time = option.time ?? 5000;
				this.toast = document.createElement('div');
			}
			Show() {
				this.toast.classList.add('toast');
				this.toast.innerText = this.string;
				this.toast.style.borderLeft = (this.color[0] !== '#' ? `solid 3px var(--${this.color})` : `solid 3px ${this.color}`)
				this.toast.addEventListener('click', () => this.Remove());
				this.toast.animate(
					[
						{ opacity: 0, transform: 'translateX(500px)' },
						{ opacity: 1, transform: 'translateX(0px)' }
					], {
					duration: 400, //再生時間（ミリ秒）
					easing: 'ease-in-out', //イージング
				})
				document.querySelector('.toastArea').insertAdjacentElement('afterbegin', this.toast);
				setTimeout(e => this.Remove(), this.time);
			}
			Remove() {
				if (this.removed) return;
				const anime = this.toast.animate(
					[
						{ opacity: 1, transform: 'translateX(0px)' },
						{ opacity: 0, transform: 'translateX(500px)' }
					], {
					duration: 400, //再生時間（ミリ秒）
					easing: 'ease-in-out', //イージング
				})
				anime.addEventListener('finish', () => {
					this.toast.remove()
					this.removed = true
				});
			}
		}

		class AudioViewer {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			View() {
				new Modal({
					buttons: [{
						iconPath: '/src/ico/x.svg',
						onClick: modal => modal.Close()
					},]
				})
					.SetTitle(this.manager.filePath.name)
					.Open(element => {
						const filePreview = document.createElement('audio');
						filePreview.classList.add('filePreview');
						filePreview.src = this.url
						filePreview.controls = true
						filePreview.volume = JSON.parse(localStorage.getItem('fileapp.player.fileVolume'))[encodeURIComponent(this.url)] ?? 0.5;
						filePreview.loop = userSettings.videoAutoLoop.value
						filePreview.load()
						if (userSettings.videoAutoPlay.value) filePreview.play()
						element.appendChild(filePreview)

						filePreview.addEventListener('volumechange', async (event) => {
							const data = JSON.parse(localStorage.getItem('fileapp.player.fileVolume'))
							data[encodeURIComponent(this.url)] = filePreview.volume
							localStorage.setItem('fileapp.player.fileVolume', JSON.stringify(data))
						});

						if ("mediaSession" in navigator) {
							const updatePositionState = () => {
								navigator.mediaSession.setPositionState({
									duration: filePreview.duration,
									playbackRate: filePreview.playbackRate,
									position: filePreview.currentTime
								});
							}
							navigator.mediaSession.metadata = new MediaMetadata({
								title: this.manager.filePath.nameWithoutExtension,
								artist: "ファイル置き場",
								album: this.manager.filePath.pathname,
							});
							filePreview.addEventListener('play', (event) => {
								navigator.mediaSession.playbackState = "playing";
							});
							filePreview.addEventListener('pause', (event) => {
								navigator.mediaSession.playbackState = "paused";
							});
							navigator.mediaSession.setActionHandler('play', async () => {
								await filePreview.play();
								navigator.mediaSession.playbackState = "playing";
							});
							navigator.mediaSession.setActionHandler('pause', () => {
								filePreview.pause();
								navigator.mediaSession.playbackState = "paused";
							});
							navigator.mediaSession.setActionHandler('seekbackward', (event) => {
								const seekTime = event.seekOffset || 5;

								filePreview.currentTime = Math.min(filePreview.currentTime - seekTime, filePreview.duration);
								updatePositionState();
							});
							navigator.mediaSession.setActionHandler('seekforward', (event) => {
								const seekTime = event.seekOffset || 5;

								filePreview.currentTime = Math.min(filePreview.currentTime + seekTime, filePreview.duration);
								updatePositionState();
							});
							navigator.mediaSession.setActionHandler('seekto', (details) => {
								if (details.fastSeek && 'fastSeek' in filePreview) {
									filePreview.fastSeek(details.seekTime);
									return;
								}
								filePreview.currentTime = details.seekTime;
							});
						}
					})
					.On('close', () => {
						navigator.mediaSession.metadata = null
						navigator.mediaSession.setPositionState(null);
					})
			}
		}

		class VideoViewer {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			View() {
				const modal = new Modal({
					buttons: [{
						iconPath: '/src/ico/arrows-pointing-out.svg',
						onClick: modal => modal.ToggleFullscreen()
					}, {
						iconPath: '/src/ico/x.svg',
						onClick: modal => modal.Close()
					},]
				})
				modal.SetTitle(this.manager.filePath.name)
					.FullScreen()
					.Open(element => {
						const filePreview = document.createElement('video');
						filePreview.classList.add('filePreview');
						filePreview.src = this.url
						filePreview.controls = true
						filePreview.volume = 0.5;
						filePreview.loop = userSettings.videoAutoLoop.value
						filePreview.load()
						if (userSettings.videoAutoPlay.value) filePreview.play()
						element.appendChild(filePreview)

						filePreview.addEventListener('volumechange', async (event) => {
							const data = JSON.parse(localStorage.getItem('fileapp.player.fileVolume'))
							data[encodeURIComponent(this.url)] = filePreview.volume
							localStorage.setItem('fileapp.player.fileVolume', JSON.stringify(data))
						});

						if ("mediaSession" in navigator) {
							navigator.mediaSession.metadata = new MediaMetadata({
								title: this.manager.filePath.nameWithoutExtension,
								artist: "ファイル置き場",
								album: this.manager.filePath.pathname
							});

							const updatePositionState = () => {
								navigator.mediaSession.setPositionState({
									duration: filePreview.duration,
									playbackRate: filePreview.playbackRate,
									position: filePreview.currentTime
								});
							}

							filePreview.addEventListener('loadeddata', () => {
								setTimeout(() => {
									const thumbnailCanvas = document.createElement('canvas')
									const drawWidth = 480
									const drawHeight = Math.floor(filePreview.videoHeight * (drawWidth / filePreview.videoWidth))
									thumbnailCanvas.width = drawWidth
									thumbnailCanvas.height = drawHeight
									thumbnailCanvas.getContext('2d').drawImage(filePreview, 0, 0, drawWidth, drawHeight)
									thumbnailCanvas.toBlob(blob => {
										const blobURL = URL.createObjectURL(blob)
										navigator.mediaSession.metadata = new MediaMetadata({
											title: this.manager.filePath.nameWithoutExtension,
											artist: "ファイル置き場",
											album: this.manager.filePath.pathname,
											artwork: [{
												src: blobURL,
												sizes: `${drawWidth}x${drawHeight}`,
												type: 'image/png'
											}]
										});
										modal.On('close', () => {
											URL.revokeObjectURL(blobURL)
										})
									})
								}, 1000)
							})

							filePreview.addEventListener('play', async (event) => {
								navigator.mediaSession.playbackState = "playing";
							});

							filePreview.addEventListener('pause', (event) => {
								navigator.mediaSession.playbackState = "paused";
							});

							navigator.mediaSession.setActionHandler('play', async () => {
								await filePreview.play();
								navigator.mediaSession.playbackState = "playing";
							});

							navigator.mediaSession.setActionHandler('pause', () => {
								filePreview.pause();
								navigator.mediaSession.playbackState = "paused";
							});

							navigator.mediaSession.setActionHandler('seekbackward', (event) => {
								const seekTime = event.seekOffset || 10;

								filePreview.currentTime = Math.min(filePreview.currentTime - seekTime, filePreview.duration);
								updatePositionState();
							});
							navigator.mediaSession.setActionHandler('seekforward', (event) => {
								const seekTime = event.seekOffset || 10;

								filePreview.currentTime = Math.min(filePreview.currentTime + seekTime, filePreview.duration);
								updatePositionState();
							});
							navigator.mediaSession.setActionHandler('seekto', (details) => {
								if (details.fastSeek && 'fastSeek' in filePreview) {
									filePreview.fastSeek(details.seekTime);
									return;
								}
								filePreview.currentTime = details.seekTime;
							});
						}
					})
					.On('close', () => {
						navigator.mediaSession.metadata = null
						navigator.mediaSession.setPositionState(null);
					})
			}
		}

		class PDFViewer {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			View() {
				new Modal({
					buttons: [{
						iconPath: '/src/ico/arrows-pointing-out.svg',
						onClick: modal => modal.ToggleFullscreen()
					}, {
						iconPath: '/src/ico/x.svg',
						onClick: modal => modal.Close()
					},]
				})
					.SetTitle(this.manager.filePath.name)
					.FullScreen()
					.Open(element => {
						element.style.padding = '0'
						const filePreview = document.createElement('iframe');
						filePreview.classList.add('filePreview');
						filePreview.src = '/src/pdfjs/web/viewer.html?file=' + this.url
						filePreview.frameBorder = 0
						filePreview.classList.add('pdf')
						element.appendChild(filePreview)
					})
			}
		}

		class MarkDownViewer {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			View() {
				new Modal({
					buttons: [{
						iconPath: '/src/ico/arrows-pointing-out.svg',
						onClick: modal => modal.ToggleFullscreen()
					}, {
						iconPath: '/src/ico/x.svg',
						onClick: modal => modal.Close()
					},]
				})
					.SetTitle(this.manager.filePath.name)
					.Open(async element => {
						const filePreview = document.createElement('div');
						filePreview.classList.add('filePreview');
						const text = await (await fetch(this.url)).text();
						filePreview.innerHTML = markdown.parse(text)
						element.appendChild(filePreview)
					})
			}
		}

		class HTMLViewer {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
				this.Reload = () => { }
			}
			View() {
				const modal = new Modal({
					buttons: [{
						iconPath: '/src/ico/arrows-pointing-out.svg',
						onClick: modal => modal.ToggleFullscreen()
					}, {
						iconPath: '/src/ico/reload.svg',
						onClick: () => this.Reload()
					}, {
						iconPath: '/src/ico/x.svg',
						onClick: modal => modal.Close()
					},]
				})
				modal.SetTitle(this.manager.filePath.name)
					.FullScreen()
					.Open(async element => {
						const filePreview = document.createElement('iframe');
						filePreview.style.backgroundColor = 'white'
						filePreview.classList.add('filePreview');
						filePreview.src = this.url
						filePreview.frameBorder = 0
						filePreview.addEventListener('load', () => {
							modal.SetTitle(`${filePreview.contentDocument.title || 'タイトルなし'} (${this.manager.filePath.name})`)
							this.Reload = () => filePreview.contentDocument.location.reload()
						})
						element.appendChild(filePreview)
					})
			}
		}

		class ImageViewer {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			View() {
				new Modal({
					buttons: [{
						iconPath: '/src/ico/arrows-pointing-out.svg',
						onClick: modal => modal.ToggleFullscreen()
					}, {
						iconPath: '/src/ico/x.svg',
						onClick: modal => modal.Close()
					},]
				})
					.SetTitle(this.manager.filePath.name)
					.FullScreen()
					.Open(async element => {
						const filePreview = document.createElement('img');
						filePreview.classList.add('filePreview');
						filePreview.src = this.url
						filePreview.classList.add('filePreview')
						element.appendChild(filePreview)
					})
			}
		}

		class CodeViewer {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			View() {
				new Modal({
					buttons: [{
						iconPath: '/src/ico/arrows-pointing-out.svg',
						onClick: modal => modal.ToggleFullscreen()
					}, {
						iconPath: '/src/ico/x.svg',
						onClick: modal => modal.Close()
					},]
				})
					.SetTitle(this.manager.filePath.name)
					.FullScreen()
					.Open(async element => {
						const filePreview = document.createElement('pre');
						filePreview.classList.add('filePreview');
						const code = document.createElement('code');
						filePreview.appendChild(code);
						const text = await (await fetch(this.url)).text();
						code.textContent = text;
						hljs.highlightElement(code);
						hljs.lineNumbersBlock(code, { singleLine: true });
						element.appendChild(filePreview)
					})
			}
		}

		class CodeEditor {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
				this.savedData = ''
				this.Save = () => { }
				this.Close = () => { }
				this.Download = () => { }
			}
			View() {
				const modal = new Modal({
					buttons: [
						{
							iconPath: '/src/ico/arrow-down-tray.svg',
							onClick: () => this.Download()
						}, {
							iconPath: '/src/ico/document-arrow-up.svg',
							onClick: () => this.Save()
						}, {
							iconPath: '/src/ico/x.svg',
							onClick: () => this.Close()
						},
					]
				})

				modal.SetTitle('読み込み中...')
					.FullScreen()
					.Open(async element => {
						element.style.padding = 0
						const text = await (await fetch(this.url)).text();
						this.savedData = text
						require.config({
							paths: {
								'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.40.0/min/vs'
							}, 'vs/nls': {
								availableLanguages: {
									"*": "ja"
								}
							}
						});
						require(["vs/editor/editor.main"], () => {
							const editor = monaco.editor.create(element, {
								value: text,
								theme: 'vs-dark',
								language: 'auto',
								automaticLayout: true
							});
							modal.SetTitle(this.manager.filePath.name)
							try {
								const model = monaco.editor.createModel(text, undefined, monaco.Uri.file(this.url));
								editor.setModel(model);
							} catch (e) {
								console.error(e)
							}

							const setIsSavedToTitle = () => {
								const changed = (this.savedData !== editor.getValue())
								changed ? modal.SetTitle(`${this.manager.filePath.name}(未保存)`) : modal.SetTitle(this.manager.filePath.name)
							}

							editor.getModel().onDidChangeContent(setIsSavedToTitle);

							this.Download = () => {
								const text = editor.getValue()
								const blob = new Blob([text], { type: "text/plain" });
								const downloadLink = document.createElement("a");
								downloadLink.download = this.manager.filePath.name;
								downloadLink.href = URL.createObjectURL(blob);
								downloadLink.style.display = "none";
								document.body.appendChild(downloadLink);
								downloadLink.click()
								downloadLink.remove()
								URL.revokeObjectURL(downloadLink.href);
							}
							this.Save = async () => {
								const text = editor.getValue()
								const blob = new Blob([text], { type: "text/plain" });
								const file = new File([blob], this.manager.filePath.name, { type: blob.type })
								const formData = new FormData();
								formData.append('filebody', file);
								await (await fetch(`${this.url}?source=upload`, {
									method: 'POST',
									body: formData
								}))
								this.savedData = text
								setIsSavedToTitle()
							}
							this.Close = () => {
								if (this.savedData === editor.getValue()) {
									return modal.Close()
								}
								if (confirm('変更した内容を保存しますか?')) {
									this.Save()
								}
								modal.Close()
							}
						});
					})
			}
		}

		class FileappExecuter {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			async View() {
				document.body.style.cursor = 'progress'
				const imported = await import(this.url)
				document.body.style.cursor = null
				if (typeof imported.run !== 'function') return new Toast('このアプリは実行できません', { color: 'red', time: 5000 }).Show()
				imported.run()
			}
		}

		class DefaultViewer {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			View() {
				new Modal({
					buttons: [{
						iconPath: '/src/ico/arrows-pointing-out.svg',
						onClick: modal => modal.ToggleFullscreen()
					}, {
						iconPath: '/src/ico/x.svg',
						onClick: modal => modal.Close()
					},]
				})
					.SetTitle(this.manager.filePath.name)
					.Open(async element => {
						const filePreview = document.createElement('iframe');
						filePreview.classList.add('filePreview');
						filePreview.src = this.url
						filePreview.frameBorder = 0
						filePreview.sandbox = 'allow-scripts allow-pointer-lock	allow-presentation'
						element.appendChild(filePreview)
					})
			}
		}

		class VideoPreviewer {
			#didShowed = false
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			ReturnElement() {
				const filePreview = document.createElement('video');
				filePreview.src = this.url
				filePreview.muted = true;
				filePreview.loop = true;
				filePreview.preload = 'none';
				filePreview.playsInline = true;
				filePreview.disablePictureInPicture = true;
				let touchStartTimestamp = 0
				filePreview.addEventListener('touchstart', e => {
					touchStartTimestamp = performance.now()
					filePreview.play()
				}, false);
				filePreview.addEventListener('touchend', e => {
					// 長押し(100ms)じゃなかったら通常動作
					if ((performance.now() - touchStartTimestamp) < 100) {
						filePreview.click()
					}
					e.preventDefault()
					filePreview.pause()
				}, false);
				filePreview.addEventListener('mouseover', () => filePreview.play(), false);
				filePreview.addEventListener('mouseleave', () => filePreview.pause(), false);
				const observer = new IntersectionObserver(entries => entries.forEach(entry => {
					if (!entry.isIntersecting) return
					if (this.#didShowed) return
					this.#didShowed
					filePreview.load()
				}), {
					root: document.body,
					rootMargin: '0px',
					threshold: 0
				});
				observer.observe(filePreview);
				filePreview.classList.add('files.preview')
				return filePreview
			}
		}

		class PDFPreviewer {
			#didShowed = false
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			ReturnElement() {
				const filePreview = document.createElement('img');
				filePreview.src = "/src/ico/textfile.svg"
				filePreview.alt = ''
				filePreview.style.width = '48px'
				filePreview.style.height = '48px'
				const Load = () => {
					if (this.#didShowed === true) return
					if (!(window.loaded === true)) return window.addEventListener('load', () => Load(), { once: true })
					const drawCanvas = document.createElement('canvas');
					drawCanvas.width = 1280;
					drawCanvas.height = 720;
					const pdfjsLib = window['pdfjs-dist/build/pdf'];
					pdfjsLib.GlobalWorkerOptions.workerSrc = '/src/pdfjs/build/pdf.worker.js';
					const loadingTask = pdfjsLib.getDocument(this.url);
					loadingTask.promise.then((pdf) => {
						pdf.getPage(1).then(page => {
							const viewport = page.getViewport({ scale: 1 });
							drawCanvas.width = viewport.width
							drawCanvas.height = viewport.height
							drawCanvas.style.width = Math.floor(viewport.width) + "px";
							drawCanvas.style.height = Math.floor(viewport.height) + "px";
							const context = drawCanvas.getContext("2d", { willReadFrequently: true });
							// Render PDF page into canvas context
							const renderContext = {
								canvasContext: context,
								viewport: viewport,
							};
							const renderTask = page.render(renderContext);
							renderTask.promise.then(() => {
								const imageData = drawCanvas.toDataURL();
								filePreview.src = imageData
								filePreview.style.width = 'inherit'
								filePreview.style.height = 'inherit'
							});
							this.#didShowed = true
						});
					}, (reason) => {
						// PDF loading error
						console.error(reason);
					}
					);
				}
				const observer = new IntersectionObserver(entries => entries.forEach(entry => entry.isIntersecting ? Load() : ''), {
					root: document.body,
					rootMargin: '0px',
					threshold: 0
				});
				observer.observe(filePreview);
				filePreview.classList.add('files.preview')
				return filePreview
			}
		}

		class ImagePreviewer {
			constructor(path) {
				this.path = path
				this.manager = new FileManager(path)
				this.url = FILES_ROOT + path.replaceAll('#', '%23')
			}
			ReturnElement() {
				const filePreview = document.createElement('img');
				filePreview.loading = 'lazy'
				filePreview.decoding = 'async'
				filePreview.fetchPriority = 'low'
				filePreview.src = this.url
				filePreview.alt = name
				filePreview.addEventListener('load', () => {
					//画像解像度
					const imageWidth = filePreview.naturalWidth
					const imageHeight = filePreview.naturalHeight
					if (imageWidth <= filePreview.width || imageHeight <= filePreview.height) {
						filePreview.style.imageRendering = 'pixelated'
					}
				}, { once: true })
				filePreview.classList.add('files.preview')
				return filePreview
			}
		}

		class AddedFile {
			status = {
				Progress: evt => {
					const percent = ((evt.loaded / evt.total) * 100).toFixed(1)
					this.DOM.querySelector('progress').value = percent / 100
					this.DOM.querySelector('.filename').innerText = `${this.name} - ${percent}%`
				},
				Abort: evt => {
					new Toast('中止しました', { color: 'red', time: 5000 }).Show()
					this.DOM.querySelector('.filename').innerText = `${this.name} - 中止`
				},
				Error: evt => {
					new Toast('エラーが発生しました', { color: 'red', time: 5000 }).Show()
					this.DOM.querySelector('.filename').innerText = `${this.name} - エラー`
				},
				Timeout: evt => {
					new Toast('タイムアウトが発生しました', { color: 'red', time: 5000 }).Show()
					this.DOM.querySelector('.filename').innerText = `${this.name} - タイムアウト`
				},
				Load: evt => {
					this.isUpload = true
					new Toast(`${this.name}をアップロードしました`, { color: 'green', time: 5000 }).Show()
					this.DOM.querySelector('.filename').innerText = `${this.name} - 完了`
					this.DOM.querySelector('progress').style.accentColor = 'var(--green)'
				}
			}
			constructor(fileObject, setting) {
				this.fileObj = fileObject
				this.name = setting.name ?? fileObject.name
				this.type = setting.type ?? fileObject.type
				this.target = setting.target ?? mainDirectoryViewer.path
				this.isUpload = false
				this.openable = setting.openable ?? true
				this.DOM = null
				this.XMLHttpRequest = new XMLHttpRequest()
				this.XMLHttpRequest.upload.addEventListener('progress', e => this.status.Progress(e))
				this.XMLHttpRequest.upload.addEventListener('abort', e => this.status.Abort())
				this.XMLHttpRequest.upload.addEventListener('error', e => this.status.Error())
				this.XMLHttpRequest.upload.addEventListener('timeout', e => this.status.Timeout())
				this.XMLHttpRequest.upload.addEventListener('load', e => this.status.Load())
			}
			static OpenModal(show) {
				if (show === true) {
					document.getElementsByClassName('modalbg')[0].style.display = 'flex'
				} else {
					document.getElementsByClassName('modalbg')[0].style.display = 'none'
				}
			}
			static modal = {
				Open: () => {
					document.getElementsByClassName('modalbg')[0].style.display = 'flex'
				},
				Close: () => {
					document.getElementsByClassName('modalbg')[0].style.display = 'none'
				},
				FormReset: check => {
					if (check === true) {
						if (confirm('リセットしてもよろしいですか?')) {
							fileInput.value = ''
							fileName.value = ''
						}
					} else {
						fileInput.value = ''
						fileName.value = ''
					}
				},
			}
			static FileUpload() {
				if (fileInput.files.length === 0 && fileName.value.length === 0) {
					alert('ファイルを選択してファイル名を入力してください')
					return false
				} else if (fileInput.files.length === 0) {
					alert('ファイルを選択してください')
					return false
				} else if (fileName.value.length === 0) {
					alert('ファイル名を入力して下さい')
					return false
				}
				modals.fileUpload.Close()
				Array.from(fileInput.files).forEach(file => {
					new AddedFile(file, {
						name: fileInput.files.length === 1 ? fileName.value : undefined
					})
						.Show()
						.Upload()
				})
			}
			Show() {
				const imgExtension = ['jpg', 'jepg', 'png', 'gif', 'tiff', 'tif', 'bmp'];
				const template = document.getElementById('uploadfileicotemplate')
				const clone = template.content.cloneNode(true);
				const newElement = document.createElement("div");
				newElement.classList.add("fileChild", "uploadfile");
				this.DOM = clone.querySelector('.fileinfo')
				document.querySelector('.uploadfiles').appendChild(newElement);
				if (this.type.includes('image')) {
					const previewIcon = clone.querySelector('img');
					const reader = new FileReader();
					reader.onload = e => previewIcon.src = e.target.result;
					reader.readAsDataURL(this.fileObj);
					previewIcon.setAttribute('alt', this.name);
					clone.querySelector('.filename').innerText = this.name;
				} else {
					const previewIcon = clone.querySelector('img');
					previewIcon.classList.remove('files.preview')
					previewIcon.src = '/src/ico/file.png';
					previewIcon.alt = this.name;
					clone.querySelector('.filename').innerText = this.name;
				}
				newElement.appendChild(clone);
				newElement.addEventListener('click', () => this.Open());
				newElement.querySelector('.filemenu').addEventListener('click', (e) => {
					e.stopPropagation();
					this.Context();
				})
				newElement.addEventListener('contextmenu', (e) => {
					e.preventDefault();
					this.Context();
				}, true);
				return this
			}
			Upload() {
				this.isUpload = false
				const formData = new FormData();
				formData.append('filebody', this.fileObj);
				this.XMLHttpRequest.open('POST', `/api/files/${this.target + this.name}?source=upload`, true);
				this.XMLHttpRequest.send(formData);
			}
			Abort() {
				if (this.isUpload) {
					alert('すでに送信済みです')
					return
				}
				this.XMLHttpRequest.abort();
			}
			NameCopy() {
				const text = encodeURI(this.name)
				util.CopyToClipboard(text) ? new Toast(`コピーしました`, { color: 'green', time: 5000 }).Show() : new Toast(`コピーに失敗しました`, { color: 'red', time: 5000 }).Show()
			}
			URLCopy() {
				const text = encodeURI(BASE_URL + this.name)
				util.CopyToClipboard(text) ? new Toast(`コピーしました`, { color: 'green', time: 5000 }).Show() : new Toast(`コピーに失敗しました`, { color: 'red', time: 5000 }).Show()
			}
			async Open() {
				if (!this.openable) {
					alert('ファイルを開けません')
					return false
				}
				const template = document.getElementById('filepreviewtemplate');
				const videoExtension = ['mp4', 'mpg', 'avi', 'wmv', 'mkv', 'ts', 'webm', 'mov', 'm2ts'];
				const audioExtension = ['mp3', 'ogg', 'wav', 'wma'];
				const imgExtension = ['jpg', 'jepg', 'png', 'gif', 'tiff', 'tif', 'bmp', 'svg', 'webp'];
				const codeExtension = ['js', 'html', 'htm', 'xml', 'css', 'php', 'yaml', 'py', 'wasm', 'json', 'c', 'cc', 'cp', 'cpp', 'cxx', 'rb', 'rmd', 'swift', 'h', 'm', 'graphql', 'gql', 'rs', 'go', 'java', 'sql', 'pl'];
				const markDownExtension = ['md'];
				const previewBackGround = document.createElement('div');
				previewBackGround.classList.add('filebg', 'modalbg');
				document.body.appendChild(previewBackGround);
				const clone = template.content.cloneNode(true);
				let filePreview
				const reader = new FileReader();
				if (this.type.includes('video/')) {
					filePreview = document.createElement('video');
					reader.onload = e => filePreview.src = e.target.result;
					reader.readAsDataURL(this.fileObj);
					filePreview.setAttribute('controls', '');
					filePreview.setAttribute('id', 'filepreview');
					filePreview.volume = 0.5;
					filePreview.loop = true;
				} else if (this.type.includes('audio/')) {
					filePreview = document.createElement('audio');
					reader.onload = e => filePreview.src = e.target.result;
					reader.readAsDataURL(this.fileObj);
					filePreview.setAttribute('controls', '');
					filePreview.setAttribute('id', 'filepreview');
					filePreview.volume = 0.5;
					filePreview.loop = true;
				} else if (markDownExtension.includes(filePath.GetExtension(this.name))) {
					filePreview = document.createElement('div');
					reader.onload = e => {
						const text = e.target.result
						filePreview.style.height = window.innerHeight * 0.6 + 'px'
						filePreview.innerHTML = markdown.parse(text)
					};
					reader.readAsText(this.fileObj);
				} else if (this.type.includes('image/')) {
					filePreview = document.createElement('img');
					reader.onload = e => filePreview.src = e.target.result;
					reader.readAsDataURL(this.fileObj);
					filePreview.setAttribute('alt', this.name);
					filePreview.setAttribute('id', 'filepreview');
				} else if (codeExtension.includes(filePath.GetExtension(this.name))) {
					filePreview = document.createElement('pre');
					reader.onload = e => {
						const code = document.createElement('code')
						filePreview.appendChild(code)
						const text = e.target.result
						code.textContent = text
						code.style.height = window.innerHeight * 0.6 + 'px'
						hljs.highlightElement(code)
					};
					reader.readAsText(this.fileObj);
				} else if (this.type.includes('text/')) {
					filePreview = document.createElement('div');
					reader.onload = e => filePreview.textContent = e.target.result;
					reader.readAsText(this.fileObj);
				} else {
					filePreview = document.createElement('div');
					filePreview.innerText = '表示できないファイルです。'
				}
				clone.querySelector('.file__title').textContent = this.name;
				clone.querySelector('.file__body').appendChild(filePreview);
				clone.querySelector('.filepreviewclose').addEventListener('click', () => {
					previewBackGround.remove();
				}, false);
				previewBackGround.appendChild(clone);
			}
			Context() {
				new ContextMenu({
					menuList: [
						{
							text: 'ファイル名をコピー',
							onClick: () => this.NameCopy(),
						}, {
							text: 'ファイルのURLをコピー',
							onClick: () => this.URLCopy()
						}, {
							type: 'line'
						}, {
							text: 'アップロードの中断',
							onClick: () => this.Abort()
						}, {
							text: '再送信',
							onClick: () => this.Upload()
						}
					]
				}).Show()
			}
		}

		class FileFolderManager {
			constructor(path, fileInfo) {
				this.path = path
				this.size = fileInfo?.size
				this.filePath = new FilePath(path)
				this.favorite = new FavoriteManager(path)
			}
			async IsExits() {
				try {
					return await (await fetch(`/api/files/${this.path}`, { method: 'HEAD' })).ok
				} catch (e) {
					return false
				}
			}
			async Delete() {
				return await (await fetch(`/api/files/${this.path}`, { method: 'DELETE' })).ok
			}
			async Stat() {
				return await (await fetch(`/api/files/${this.path}?info`, { method: 'GET' })).text()
			}
			async Rename(name) {
				return await (await fetch(`/api/files/${this.path}?cmd=rename&target=${name}`, { method: 'PATCH' })).ok
			}
		}

		class FileManager extends FileFolderManager {
			constructor(path, fileInfo) {
				super(path, fileInfo)
				this.path = path
				this.size = fileInfo?.size
				this.filePath = new FilePath(path)
			}
		}

		class FolderManager extends FileFolderManager {
			constructor(path, fileInfo) {
				super(path, fileInfo)
				this.path = path
				this.size = fileInfo?.size
				this.filePath = new FilePath(path)
			}
			async createFolder({
				name
			}) {
				await fetch(`/api/files/${this.path + name}/`, { method: 'POST' });
			}
			async Rename(name) {
				return await (await fetch(`/api/files/${this.path}/?cmd=rename&target=${name}`, { method: 'PATCH' })).ok
			}
		}

		class FavoriteManager {
			static list = new Array()
			static {
				if (localStorage.getItem('favoriteList') === null) {
					localStorage.setItem('favoriteList', JSON.stringify([]))
				} else {
					FavoriteManager.list = JSON.parse(localStorage.getItem('favoriteList'))
				}
			}
			constructor(path) {
				this.path = path
			}
			get isListed() {
				return FavoriteManager.list.includes(this.path)
			}
			Add() {
				if (this.isListed) {
					return new Error('すでに登録済みです')
				}
				FavoriteManager.list.push(this.path)
				localStorage.setItem('favoriteList', JSON.stringify(FavoriteManager.list))
			}
			Remove() {
				const index = FavoriteManager.list.indexOf(this.path)
				if (index === -1) {
					return
				}
				FavoriteManager.list.splice(index, 1)
				localStorage.setItem('favoriteList', JSON.stringify(FavoriteManager.list))
			}
		}

		class FileUIBase {
			constructor(path) {
				this.path = path
			}
		}

		class FileUI extends FileUIBase {
			constructor(path, fileInfo, setting) {
				super(path)
				this.manager = new FileManager(path, fileInfo)
				this.disablePreview = setting?.disablePreview ?? false
			}
			get iconPath() {
				return (extensions[this.manager.filePath.extension.toLowerCase()]?.iconPath ?? filetypes.default.iconPath)
			}
			get fileViewer() {
				return extensions[this.manager.filePath.extension.toLowerCase()]?.fileViewer ?? filetypes.default.fileViewer
			}
			get filePreviewer() {
				return extensions[this.manager.filePath.extension.toLowerCase()]?.filePreviewer
			}
			async Open(Viewer) {
				Viewer ? new Viewer(this.path).View() : new this.fileViewer(this.path).View()
			}
			NameCopy() {
				const text = this.manager.filePath.name
				util.CopyToClipboard(text) ? new Toast(`コピーしました`, { color: 'green', time: 5000 }).Show() : new Toast(`コピーに失敗しました`, { color: 'red', time: 5000 }).Show()
			}
			URLCopy() {
				const text = encodeURI(BASE_URL + this.path)
				util.CopyToClipboard(text) ? new Toast(`コピーしました`, { color: 'green', time: 5000 }).Show() : new Toast(`コピーに失敗しました`, { color: 'red', time: 5000 }).Show()
			}
			DirectFileURLCopy() {
				const text = encodeURI(location.origin + '/' + FILES_ROOT + this.path)
				util.CopyToClipboard(text) ? new Toast(`コピーしました`, { color: 'green', time: 5000 }).Show() : new Toast(`コピーに失敗しました`, { color: 'red', time: 5000 }).Show()
			}
			async Rename() {
				const name = prompt('名前を入力してください', this.manager.filePath.name)
				if (Boolean(name) === false) return false;
				(await this.manager.Rename(name) == true) ? new Toast(`${this.manager.filePath.name}を名前変更しました。`, { color: 'green', time: 5000 }).Show() : new Toast(`エラーが発生しました`, { color: 'red', time: 5000 }).Show()
			}
			async Delete() {
				(await this.manager.Delete() == true) ? new Toast(`${this.manager.filePath.name}を削除しました。`, { color: 'green', time: 5000 }).Show() : new Toast(`エラーが発生しました`, { color: 'red', time: 5000 }).Show()
			}
			WindowOpen() {
				window.open(FILES_ROOT + this.path, 'filepreview.' + Math.random(), 'top=100,left=100,width=960,height=540,toolbar=yes,menubar=yes,scrollbars=yes')
			}
			Download() {
				const downloadElement = document.getElementById('jsdownload')
				downloadElement.href = `/api/files/${this.path}`
				downloadElement.click()
			}
			Share() {
				const ex = this.manager.filePath.extension.toLowerCase();
				const name = this.manager.filePath.name;
				const URL = encodeURI(BASE_URL + this.path)
				new Modal()
					.SetTitle(this.manager.filePath.name)
					.SetContent(document.querySelector('#filesharetemplate'))
					.Open(element => {
						element.querySelector('.url').value = URL;
						const QRcode = new QRCode(element.querySelector('.QRcode'), {
							text: URL,
							width: 256,
							height: 256,
							colorDark: "#000000",
							colorLight: "#ffffff",
							correctLevel: QRCode.CorrectLevel.L
						});
						element.querySelector('.url').addEventListener('input', () => QRcode.makeCode(element.querySelector('.url').value), false);
					})
			}
			async fileBodyShare() {
				if (!navigator.canShare)
					return Toast(`対応していません`, { color: 'red', time: 5000 }).Show()
				const downloadToast = new Toast(`ダウンロード中です...`, { color: 'blue', time: Infinity })
				downloadToast.Show()
				const fileBlob = await (await fetch(FILES_ROOT + this.path)).blob()
				navigator.share({
					files: [new File([fileBlob], this.manager.filePath.name, { type: fileBlob.type })]
				}).then(() => {
					new Toast(`完了しました`, { color: 'green', time: 5000 }).Show()
				}).catch(e => {
					console.error(e)
					if (e.includes('Permission denied')) return new Toast(`エラーが発生しました。\n共有できないタイプのファイルです。`, { color: 'red', time: 5000 }).Show()
				}).finally(() => {
					downloadToast.Remove()
				})
			}
			Context() {
				new ContextMenu({
					menuList: [
						{
							text: '開く',
							onClick: () => this.Open(),
						}, {
							text: '次から開く',
							icon: '/src/ico/chevron-right.svg',
							submenu: [
								...fileViewers.map(i => ({ text: i.name, onClick: () => this.Open(i.viewer) }))
							]
						}, {
							text: '新規ウィンドウで直接開く',
							onClick: () => this.WindowOpen(),
							icon: '/src/ico/arrow-top-right-on-square.svg'
						}, {
							type: 'line'
						}, {
							text: 'クリップボードにコピー',
							icon: '/src/ico/chevron-right.svg',
							submenu: [
								{
									text: 'ファイル名をコピー',
									onClick: () => this.NameCopy(),
								}, {
									text: 'ファイルのURLをコピー',
									onClick: () => this.URLCopy(),
								}, {
									text: 'ファイルの直接URLをコピー',
									onClick: () => this.DirectFileURLCopy(),
								}
							]
						}, {
							type: 'line'
						}, {
							text: (() => {
								return `お気に入り${this.manager.favorite.isListed ? 'を解除' : 'に追加'}`;
							})(),
							onClick: () => {
								this.manager.favorite.isListed ? this.manager.favorite.Remove() : this.manager.favorite.Add()
							},
							icon: '/src/ico/star.svg'
						}, {
							text: 'ファイルのURLを共有',
							onClick: () => this.Share(),
							icon: '/src/ico/share.svg'
						}, {
							text: 'ファイル本体を共有(一部)',
							onClick: () => this.fileBodyShare(),
							icon: '/src/ico/share.svg'
						}, {
							text: 'ファイルをダウンロード',
							onClick: () => this.Download(),
							icon: '/src/ico/arrow-down-tray.svg'
						}, {
							text: '名前変更',
							onClick: () => this.Rename()
						}, {
							text: '削除',
							onClick: () => this.Delete(),
							icon: '/src/ico/trash.svg',
							style: {
								color: 'red'
							}
						}, {
							text: 'プロパティ',
							onClick: () => { }
						}
					]
				}).Show()
			}
			ReturnElement() {
				const clone = document.getElementById('fileicotemplate').content.cloneNode(true);
				clone.querySelector('.filename').innerText = this.manager.filePath.name;
				if (this.filePreviewer && !this.disablePreview) {
					clone.querySelector('.fileico').appendChild(new this.filePreviewer(this.path).ReturnElement())
				} else {
					const iconElement = document.createElement('div')
					iconElement.classList.add('fileIcon')
					iconElement.style.webkitMaskImage = `url(${this.iconPath})`
					iconElement.style.maskImage = `url(${this.iconPath})`
					clone.querySelector('.fileico').appendChild(iconElement)
				}

				const fileChildElement = document.createElement("div");
				fileChildElement.classList.add("fileChild");
				fileChildElement.draggable = true
				fileChildElement.tabIndex = 0
				fileChildElement.dataset.filePath = this.path
				fileChildElement.appendChild(clone)

				fileChildElement.addEventListener('click', () => this.Open())
				fileChildElement.addEventListener('keydown', e => {
					if (e.key !== 'Enter') return
					this.Open()
					fileChildElement.blur()
				})
				fileChildElement.querySelector('.filemenu').addEventListener('click', e => {
					e.stopPropagation()
					this.Context()
				})
				fileChildElement.addEventListener('contextmenu', e => {
					e.preventDefault();
					this.Context();
				}, true);
				//fileChildElement.addEventListener("dragstart", e => this.directoryViewerClass.draggingElement = e.target);
				return fileChildElement;
			}
		}

		class FolderUI extends FileUIBase {
			constructor(path, fileInfo, setting) {
				super(path)
				this.manager = new FolderManager(path, fileInfo)
			}
			NameCopy() {
				const text = encodeURI(this.manager.filePath.name)
				util.CopyToClipboard(text) ? new Toast(`コピーしました`, { color: 'green', time: 5000 }).Show() : new Toast(`コピーに失敗しました`, { color: 'red', time: 5000 }).Show()
			}
			URLCopy() {
				const text = encodeURI(BASE_URL + this.path + '/')
				util.CopyToClipboard(text) ? new Toast(`コピーしました`, { color: 'green', time: 5000 }).Show() : new Toast(`コピーに失敗しました`, { color: 'red', time: 5000 }).Show()
			}
			async Rename() {
				const name = prompt('名前を入力してください', this.manager.filePath.name)
				if (Boolean(name) === false) return false;
				(await this.manager.Rename(name) == true) ? new Toast(`${this.manager.filePath.name}を名前変更しました。`, { color: 'green', time: 5000 }).Show() : new Toast(`エラーが発生しました`, { color: 'red', time: 5000 }).Show()
			}
			async Delete() {
				(await this.manager.Delete() == true) ? new Toast(`${this.manager.filePath.name}を削除しました。`, { color: 'green', time: 5000 }).Show() : new Toast(`エラーが発生しました`, { color: 'red', time: 5000 }).Show()
			}
			Context() {
				new ContextMenu({
					menuList: [
						{
							text: '開く',
							onClick: () => this.Open(),
						}, {
							text: 'クリップボードにコピー',
							icon: '/src/ico/chevron-right.svg',
							submenu: [
								{
									text: 'フォルダー名をコピー',
									onClick: () => this.NameCopy(),
								}, {
									text: 'フォルダーのURLをコピー',
									onClick: () => this.URLCopy(),
								},
							]
						}, {
							text: '名前変更',
							onClick: () => this.Rename(),
						}, {
							text: '削除',
							onClick: () => this.Delete(),
							icon: '/src/ico/trash.svg',
							style: {
								color: 'red'
							}
						}
					]
				}).Show()
			}
			ReturnElement(directoryUI) {
				const clone = document.getElementById('fileicotemplate').content.cloneNode(true);
				clone.querySelector('.filename').innerText = this.manager.filePath.name;

				const iconElement = document.createElement('div')
				iconElement.classList.add('fileIcon')
				iconElement.style.webkitMaskImage = `url(${filetypes.folder.iconPath})`
				iconElement.style.maskImage = `url(${filetypes.folder.iconPath})`
				clone.querySelector('.fileico').appendChild(iconElement)

				const fileChildElement = document.createElement("div");
				fileChildElement.classList.add("fileChild");
				fileChildElement.draggable = true
				fileChildElement.tabIndex = 0
				fileChildElement.dataset.filePath = this.path
				fileChildElement.appendChild(clone)

				fileChildElement.addEventListener('click', () => this.Open(directoryUI))
				fileChildElement.addEventListener('keydown', e => {
					if (e.key !== 'Enter') return
					this.Open(directoryUI)
					fileChildElement.blur()
				})
				fileChildElement.querySelector('.filemenu').addEventListener('click', e => {
					e.stopPropagation()
					this.Context()
				})
				fileChildElement.addEventListener('contextmenu', e => {
					e.preventDefault();
					this.Context();
				}, true);
				//fileChildElement.addEventListener("dragstart", e => this.directoryViewerClass.draggingElement = e.target);
				return fileChildElement;
			}
			Open(directoryUI) {
				directoryUI.parentViewer.ChangeDirectory(this.path + '/')
			}
		}

		class DirectoryUI {
			constructor(parentElement, viewer) {
				this.parentElement = parentElement
				this.parentViewer = viewer
			}
			AddFiles(fileUIs) {
				const fragment = document.createDocumentFragment();
				fileUIs.forEach(file => {
					fragment.appendChild(file.ReturnElement(this));
				})
				this.parentElement.appendChild(fragment)
				return this
			}
			wipe() {
				this.parentElement.innerHTML = ''
			}
		}

		class DirectoryViewer extends EventRegister {
			constructor(path, settings) {
				super()
				this.parentElement = settings.parentElement ?? null
				this.filesElement = null
				this.directoryPathInputElement = null
				this.searchInputElement = null
				this.clone = null
				this.path = path
				this.draggingElement = null
				this.filesCache = {}
				this.layout = settings.layout ?? 'default'
				this.filter = { search: settings.filter?.search ?? '', types: settings.filter?.type ?? ['directory', 'file'] }
				this.directoryUI = new DirectoryUI('', this)
			}
			ShowElements() {
				this.parentElement.classList.add('directoryViewer')
				this.clone = document.getElementById('directoryViewTemplate').content.cloneNode(true);
				this.parentElement.appendChild(this.clone)

				this.searchInputElement = this.parentElement.querySelector('.search')
				this.filesElement = this.parentElement.querySelector('.files')
				this.directoryUI.parentElement = this.filesElement
				this.filesElement.dataset.layout = this.layout
				this.directoryPathInputElement = this.parentElement.querySelector('.directory')
				this.directoryPathInputElement.value = this.path
				this.parentElement.querySelector('button.back').addEventListener('click', e => {
					const dirArray = this.path.split('/')
					const targetPath = dirArray.slice(0, dirArray.length - 2).join('/') + '/'
					this.ChangeDirectory(targetPath)
				})
				this.parentElement.querySelector('.fileAddFloatButton').addEventListener('click', e => {
					modals.fileUploadList.Open()
				})
				this.searchInputElement.addEventListener('change', e => this.SetFilter({ search: e.target.value }))
				return this
			}
			async #ReturnFilesArray() {
				const filesArray = (await (await fetch(`/api/files/${this.path}`, { priority: 'high' })).json())
				const filteredArray = filesArray.filter(item => item.name.includes(this.filter.search) && this.filter.types.includes(item.type))
				return Promise.resolve(filteredArray)
			}
			async UpdateFiles() {
				const filesArray = await this.#ReturnFilesArray()
				if (JSON.stringify(this.filesCache) === JSON.stringify(filesArray)) return false
				this.filesCache = filesArray
				this.directoryUI.wipe()
				const fileLength = filesArray.length
				if (fileLength === 0) {
					this.filesElement.innerText = 'このフォルダーは空です'
				}
				else {
					this.directoryUI.AddFiles(filesArray.map(file => (file.type === 'directory') ? new FolderUI(this.path + file.name) : new FileUI(this.path + file.name, { size: file.size })))
				}
				this.Emit('updateDirectory', filesArray, fileLength)
			}
			ChangeDirectory(path) {
				this.path = path
				this.UpdateFiles('/' + path)
				this.directoryPathInputElement.innerText = path
				this.Emit('changeDirectory', path)
			}
			async MakeDir(name) {
				const response = await fetch(`/api/files/${this.path + name}/`, {
					method: 'POST'
				});
			}
			SetLayout(layout) {
				this.layout = layout
				this.filesElement.dataset.layout = layout
				return this
			}
			SetFilter(obj) {
				this.filter.search = obj.search ?? this.filter.search
				this.filter.types = obj.type ?? this.filter.types
				this.UpdateFiles()
			}
		}

		class FileFolderBase {
			constructor(path, settings) {
				this.data = settings?.data ?? {}
				this.path = path
				this.filePath = new FilePath(path)
				this.parentElement = settings?.parentElement ?? null
				this.directoryViewerClass = settings?.directoryViewer ?? null
			}
		}

		class AddedFileBase extends EventRegister {
			static files = new Array()
			constructor(targetPath) {
				this.targetPath = targetPath
				this.status = {
					isDone: false,
					isAborted: false,
					isError: false,
					percent: 0,
				}
			}
		}

		const util = {
			RandomString: length => {
				return btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(length)))).substring(0, length)
			},
			CopyToClipboard: text => {
				const textarea = document.getElementById('textarea')
				textarea.style.display = 'block',
					textarea.value = text
				textarea.select();
				setTimeout(() => textarea.style.display = 'none', 100)
				const copyResult = document.execCommand("copy");
				return copyResult
			},
			/**
				 * バイト書式変換
				 * @param {number} number 適用する数値
				 * @param {number} [point=0] 小数点の桁数
				 * @param {number} [com=1024] 1KBあたりのバイト数
				 * @return {string} 書式化された値を返す
			 */
			ByteFormat: (number, point, com) => {
				if (typeof number === 'undefined') throw '適用する数値が指定されていません。';
				if (!String(number).match(/^[0-9][0-9\.]+?/)) throw '適用する数値に誤りがあります。';
				if (!point) point = 0;
				if (!com) com = 1024;
				const bytes = Number(number),
					suffix = ['Byte', 'KB', 'MB', 'GB', 'TB', 'PB', 'ZB', 'YB'],
					target = Math.floor(Math.log(bytes) / Math.log(com));
				return (bytes / Math.pow(com, Math.floor(target))).toFixed(point) + ' ' + suffix[target];
			},
			SpeedTest: async () => {
				const Mb = 1000000;
				const start1 = performance.now();
				const data = await (await fetch(`/src/speedtest?cache=${Math.random()}`)).blob();
				const bit = data.size * 8
				const end1 = performance.now();
				const sec = ((end1 - start1) - await util.PingTest()) / 1000;
				const bytesPerSec = Math.round(bit / sec)
				const r1 = (bytesPerSec / Mb).toFixed()
				return Promise.resolve(r1);
			},
			PingTest: async () => {
				const pingStart = await performance.now();
				const pingFetch = await fetch(`/api/ping`, { method: 'HEAD' });
				const pingEnd = await performance.now();
				const ping = pingEnd - pingStart;
				return Promise.resolve(ping);
			},
			Css: e => {
				const t = document.createElement('style');
				t.textContent = e;
				document.head.appendChild(t);
			},
			UpdateThemeColor: () => {
				document.getElementById('themecolor').setAttribute('content', getComputedStyle(document.body).getPropertyValue('--background-secondary'))
			},
			StringLength: string => {
				const segmenter = new Intl.Segmenter("ja", { granularity: "grapheme" });
				return [...segmenter.segment(string)].length;
			},
			StringToBool: string => {
				if (string === 'true') return true
				else if (string === 'false') return false
				else return null
			},
			watchObjProperty: (obj, propertyName, callback) => {
				let value = obj[propertyName];
				Object.defineProperty(obj, propertyName, {
					get: () => value,
					set: newValue => {
						const oldValue = value;
						value = newValue;
						callback(oldValue, value);
					}
				});
			},
			ReturnWatchArray: (array, callback) => {
				let deletedArray = null;
				return new Proxy(array, {
					// プロパティ削除時の動作をカスタマイズ
					deleteProperty: (target, property) => {
						// 削除操作呼び出し直後は empty item になるため、
						deletedArray = [...array];
						const result = Reflect.deleteProperty(target, property);
						return result;
					},
					// プロパティ設定時の動作をカスタマイズ
					set: (target, property, val, receiver) => {
						const oldArray = [...array];
						const result = Reflect.set(target, property, val, receiver);
						if (deletedArray) {
							// 削除操作を伴う場合の検知
							callback(deletedArray, target);
							deletedArray = null;
						} else if (property !== 'length') {
							// その他：追加や変更の検知
							callback(oldArray, target);
						}
						return result;
					},
				});
			},
			VibrateScreen: (strength = 1, times = 20) => {
				let count = 0
				const Vibrate = () => {
					count++
					document.body.style.transform = `translate(${util.RandomNumber(strength * 10, -(strength * 10))}px, ${util.RandomNumber(strength * 10, -(strength * 10))}px)`
					if (count > times) return document.body.style.transform = null
					setTimeout(Vibrate, 50);
				}
				Vibrate()
			},
			RandomInteger: (min, max) => Math.floor(Math.random() * (max - min)) + min,
			RandomNumber: (min, max) => Math.random() * (max - min) + min,
			RandomFromArray: (array) => array[Math.floor(Math.random() * array.length)],
			ToSha1: async (text) => {
				const uint8 = new TextEncoder().encode(text)
				const digest = await crypto.subtle.digest('SHA-1', uint8)
				return Array.from(new Uint8Array(digest)).map(v => v.toString(16).padStart(2, '0')).join('')
			}
		}

		if (window.navigator.standalone) {
			util.Css/*css*/`
			* {
				-webkit-tap-highlight-color: rgba(0, 0, 0, 0);
				-webkit-user-select: none;
				touch-action:manipulation
			}
			input{
				-webkit-user-select: text;
				touch-action:unset;
			}
			`
			document.querySelector('meta[name=viewport]').content = 'width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover'
			//window.visualViewport.addEventListener('resize', () => {
			//	new Toast(`resize`, { color: 'blue', time: 100 }).Show()
			//	document.documentElement.style.height = `${window.visualViewport.height}px`
			//	document.body.style.height = '100%'
			//})

		};

		const modals = {
			fileUploadList: {
				Open: () => {
					const modal = new Modal()
						.SetTitle('ファイルを追加')
						.SetContent(document.querySelector('#fileAddTemplate'))
						.Open(element => {
							ChangeTitle('ファイルを追加')
							element.querySelector('button[data-name=fromLocal]').addEventListener('click', () => {
								modal.Close()
								modals.fileUpload.Open()
							})
							element.querySelector('button[data-name=fromYoutube]').addEventListener('click', () => {
								modal.Close()
								modals.fromYoutube.Open()
							})
							element.querySelector('button[data-name=folder]').addEventListener('click', async () => {
								modal.Close()
								const name = prompt('フォルダー名を入力してください')
								if (Boolean(name) === false) {
									return false
								}
								mainDirectoryViewer.MakeDir(name)
							})
						})
					modal.On('close', () => ChangeTitle())
				}
			},
			fileUpload: {
				Open: () => {
					const modal = new Modal()
						.SetTitle('ファイルをアップロード')
						.SetContent(document.querySelector('#fileUploadTemplate'))
						.Open(element => {
							ChangeTitle('ファイルをアップロード')
							const dropZone = element.querySelector('div[data-name=dropZone]')
							const fileInput = element.querySelector('input[data-name=fileSelect]')
							const fileNameInput = element.querySelector('input[data-name=filename]')
							const fileName = element.querySelector('span[data-name=fileName]')
							const fileSize = element.querySelector('span[data-name=fileSize]')
							const fileTime = element.querySelector('span[data-name=fileTime]')
							const uploadButton = element.querySelector('button[data-name=uploadBtn]')
							const formReturnButton = element.querySelector('button[data-name=FormReturn]')
							const FileChange = fileList => {
								const files = Array.from(fileList)
								let size = 0
								files.forEach(file => size += file.size)
								fileSize.innerText = util.ByteFormat(size)
								fileName.innerText = files.length === 1 ? files[0].name : `${files[0].name} ほか${files.length - 1}件のファイル`
								fileNameInput.value = files[0].name
								if (files.length === 1) {
									fileNameInput.removeAttribute('disabled')
								}
								else {
									fileNameInput.setAttribute('disabled', true)
								}
							}
							dropZone.addEventListener('dragover', e => {
								e.stopPropagation();
								e.preventDefault();
							}, false);

							dropZone.addEventListener('dragleave', e => {
								e.stopPropagation();
								e.preventDefault();
							}, false);

							dropZone.addEventListener('drop', e => {
								e.stopPropagation();
								e.preventDefault();
								const files = e.dataTransfer.files
								fileInput.files = files; //inputのvalueをドラッグしたファイルに置き換える。
								FileChange(files)
							}, false);

							fileInput.addEventListener('change', e => FileChange(fileInput.files), false);

							formReturnButton.addEventListener('click', e => {
								modal.Close()
								modals.fileUploadList.Open()
							})

							uploadButton.addEventListener('click', e => {
								if (fileInput.files.length === 0 && fileNameInput.value.length === 0) {
									alert('ファイルを選択してファイル名を入力してください')
									return false
								} else if (fileInput.files.length === 0) {
									alert('ファイルを選択してください')
									return false
								} else if (fileNameInput.value.length === 0) {
									alert('ファイル名を入力して下さい')
									return false
								}
								modal.Close()
								Array.from(fileInput.files).forEach(file => {
									new AddedFile(file, {
										name: fileInput.files.length === 1 ? fileNameInput.value : undefined
									})
										.Show()
										.Upload()
								})
							})
						})
					modal.On('close', () => ChangeTitle())
				}
			},
			fromYoutube: {
				Open: () => {
					const modal = new Modal()
						.SetTitle('Youtubeから追加')
						.SetContent(document.querySelector('#YoutubeTemplate'))
						.Open(element => {
							ChangeTitle('Youtubeから追加')
							element.querySelector('input[data-name=youtubeId]').addEventListener('change', async function () {
								const url = this.value;
								const preview = element.querySelector('iframe[data-name=youtubePreview]')
								const id = getURLVideoID(url)
								preview.src = `https://www.youtube.com/embed/${id}`

								const videoInfo = await (await fetch(`/api/youtube/info/${id}`)).json()

								const min = Math.floor(videoInfo.videoDetails.lengthSeconds / 60);
								const rem = Math.floor(videoInfo.videoDetails.lengthSeconds % 60);
								element.querySelector('span[data-name=videoTitle]').innerText = videoInfo.videoDetails.title
								element.querySelector('span[data-name=videoLengthSeconds]').innerText = `${min}分${rem}秒`
								element.querySelector('span[data-name=videoOwnerChannelName]').innerText = videoInfo.videoDetails.ownerChannelName

								if (!element.querySelector('input[data-name=filename]').value) {
									element.querySelector('input[data-name=filename]').value = videoInfo.videoDetails.title
								}
							})

							element.querySelector('button[data-name=FormReturn]').addEventListener('click', e => {
								modal.Close()
								modals.fileUploadList.Open()
							})

							element.querySelector('button[data-name=youtubeAddBtn]').addEventListener('click', function () {
								modal.Close()
								const url = element.querySelector('input[data-name=youtubeId]').value;
								const name = element.querySelector('input[data-name=filename]').value
								const type = element.querySelector('select.downloadType')
								const id = getURLVideoID(url)
								if (!id) {
									alert('無効なURLです')
									return false
								}
								new Toast('処理中です...(動画によっては数分かかります)', { color: 'blue', time: 3000 }).Show()
								const addedFile = new AddedFile(null, {
									name,
									type: '',
									openable: false
								}).Show()
								fetch(`/api/files/${mainDirectoryViewer.path + name}?source=youtube&id=${id}&type=${type.value}`, {
									method: 'POST'
								}).then(response => {
									const reader = response.body.getReader();
									// read() を呼ぶことで chunk を resolve する Promise が返る
									let nowDoing = 'audio'
									reader.read().then(async function processResult(result) {
										try {
											const progress = JSON.parse(new TextDecoder().decode(result.value).split('\n')[0])
											console.log(progress)
											if (progress.status === 'video download started') {
												nowDoing = 'video'
											} else if (progress.status === 'ended') {
												new Toast(`${name}を追加しました`, { color: 'green', time: '10000' }).Show()
												addedFile.DOM.querySelector('.filename').innerText = `${name}-完了`

												if (type !== 'audioonly') return
												const blob = await (await fetch(`files/${name}`)).blob();
												const fileObj = new File([blob], name, { type: 'audio/mp3' })
												addedFile.fileObj = fileObj
												addedFile.openable = true
											} else if (progress.status === 'audio video merging') {
												nowDoing = 'merging'
												addedFile.DOM.querySelector('.filename').innerText = `${name}-動画合成中`
											} else if (progress.status === 'progress') {
												addedFile.DOM.querySelector('.filename').innerText = `${name}-${nowDoing == 'audio' ? '音声' : '動画'}${progress.DownloadedPercent}%`
												addedFile.DOM.querySelector('progress').value = progress.floatDownloaded
											}
										} catch (e) {
											console.error(e)
										} finally {
											reader.read().then(processResult);
										}
									});
								})
							})
						})
					modal.On('close', () => ChangeTitle())
				},
			},
			backgroundSelect: {
				Open: () => {
					const modal = new Modal()
						.SetTitle('背景を選択')
						.SetContent(document.querySelector('#AddbackgroundTemplate'))
						.Open(async element => {
							const SetImages = async () => {
								const images = await (await fetch('/api/backgrounds/')).json()
								images.forEach(image => {
									const imgElement = document.createElement('button')
									imgElement.setAttribute('data-name', 'images')
									imgElement.style.backgroundImage = `url("/api/backgrounds/${image}")`
									imgElement.style.backgroundSize = 'cover'
									imgElement.classList.add('imageSelector')
									imgElement.addEventListener('click', () => SetBackgroundImage(image))
									element.querySelector('div[data-name=imageSelect]').appendChild(imgElement)
								})
							}
							const ClearImages = () => {
								Array.from(element.querySelectorAll('button[data-name=images]')).forEach(e => e.remove())
							}
							element.querySelector('button[data-name=imageAdd]').addEventListener('click', () => {
								element.querySelector('input[data-name=file]').click()
							})
							element.querySelector('button[data-name=imageClear]').addEventListener('click', () => SetBackgroundImage())

							element.querySelector('input[data-name=file]').addEventListener('change', () => {
								const file = element.querySelector('input[data-name=file]').files[0]
								const formData = new FormData()
								formData.append('filebody', file)
								fetch('/api/backgrounds/', {
									method: 'POST',
									body: formData
								})
									.then(res => res.text())
									.then(data => {
										if (!data === 'true') new Toast('失敗しました', { timeout: 5000, color: 'red' }).Show()
										ClearImages()
										SetImages()
									})
									.catch(err => new Toast('失敗しました', { timeout: 5000, color: 'red' }).Show())
							})
							SetImages()
						})
				}
			},
			settings: {
				Open: () => {
					const modal = new Modal()
						.SetTitle('設定')
						.Open(async element => {
							for (const [id, value] of Object.entries(userSettings)) {
								if (value.inputType == 'custom') {
									continue;
								}
								const clone = document.querySelector('#settingSimpleTemplate').content.cloneNode(true);
								clone.querySelector('.settingName').textContent = value.name
								clone.querySelector('.settingDescription').textContent = value.description
								const input = clone.querySelector('input')
								input.type = value.inputType
								value.ShowedCallback(input)
								input.addEventListener('change', e => value.Set(e))
								element.appendChild(clone)
							}
						})
				}
			}
		}

		const BASE_PATH = '/'
		const FILES_ROOT = '/api/files/'
		const BASE_URL = location.origin + '/'
		const PATH_PARAMETER = decodeURIComponent(location.pathname.replace(BASE_PATH, ''))
		const IS_BETA = new URL(location.href).searchParams.get('ver') === 'beta'
		const MILLISECOND = 1000
		let mousePosition = { x: 0, y: 0 }
		let fileUpdateIntervalms = localStorage.getItem('Interval') ?? 5000
		const wait = async ms => new Promise(resolve => setTimeout(resolve, ms));
		document.body.addEventListener("mousemove", e => {
			mousePosition.x = e.pageX;
			mousePosition.y = e.pageY;
		});
		window.addEventListener('beforeunload', event => {
			if (!userSettings.closeBeforeWarning.value) return
			if (event.cancelable === false) return
			event.preventDefault()
			event.returnValue = ''
		})
		window.matchMedia('(prefers-color-scheme: dark)').onchange = util.UpdateThemeColor

		const mainDirectoryViewer = new DirectoryViewer(filePath.GetPath(PATH_PARAMETER), { parentElement: document.querySelector(".directoryView") })
		mainDirectoryViewer.ShowElements().UpdateFiles()
		mainDirectoryViewer.On('updateDirectory', (files, length) => {
			document.getElementById('filelength').innerText = length
		})
		mainDirectoryViewer.On('changeDirectory', path => {
			const url = new URL(window.location);
			url.pathname = BASE_PATH + path
			window.history.replaceState(null, '', url.href);
		})

		const userSettings = {
			updateInterval: {
				name: 'ファイルの更新間隔',
				description: '指定した秒数ごとにファイル情報を更新します',
				value: util.StringToBool(localStorage.getItem('settings.updateInterval')) ?? 10 * MILLISECOND,
				inputType: 'number',
				Set(event) {
					if (event.target.value < 3) {
						event.target.value = 3
						return;
					}
					localStorage.setItem(`settings.updateInterval`, event.target.value * MILLISECOND)
					this.value = event.target.value * MILLISECOND
					clearInterval(fileUpdateInterval)
					fileUpdateInterval = setInterval(fileUpdateIntervalHandle, event.target.value * MILLISECOND)
				},
				ShowedCallback(inputElement) {
					inputElement.style.width = '80px'
					inputElement.min = 3
					inputElement.value = this.value / MILLISECOND
				}
			}, deepDarkMode: {
				name: '深い黒色を利用する',
				description: 'ダークモード時の黒をもっと暗くします',
				value: util.StringToBool(localStorage.getItem('settings.deepDarkMode')) ?? false,
				inputType: 'checkbox',
				Set(event) {
					localStorage.setItem(`settings.deepDarkMode`, event.target.checked)
					event.target.checked ? document.body.classList.add('deep-dark') : document.body.classList.remove('deep-dark')
					this.value = event.target.checked
					util.UpdateThemeColor()
				},
				ShowedCallback(inputElement) {
					inputElement.classList.add('toggleButton')
					inputElement.checked = this.value
				}
			}, closeBeforeWarning: {
				name: '終了時に警告',
				description: '終了時にダイアログを表示する(可能な場合)',
				value: util.StringToBool(localStorage.getItem('settings.closeBeforeWarning')) ?? false,
				inputType: 'checkbox',
				Set(event) {
					localStorage.setItem(`settings.closeBeforeWarning`, event.target.checked)
					this.value = event.target.checked
				},
				ShowedCallback(inputElement) {
					inputElement.classList.add('toggleButton')
					inputElement.checked = this.value
				}
			}, forcedFileUpdate: {
				name: '常時ファイル情報を更新',
				description: 'タブにフォーカスされていなくても更新されます',
				value: util.StringToBool(localStorage.getItem('settings.forcedFileUpdate')) ?? false,
				inputType: 'checkbox',
				Set(event) {
					localStorage.setItem(`settings.forcedFileUpdate`, event.target.checked)
					this.value = event.target.checked
				},
				ShowedCallback(inputElement) {
					inputElement.classList.add('toggleButton')
					inputElement.checked = this.value
				}
			}, videoAutoLoop: {
				name: '動画の自動ループ',
				description: '動画、音声を自動的にループをオンにします',
				value: util.StringToBool(localStorage.getItem('settings.videoAutoLoop')) ?? true,
				inputType: 'checkbox',
				Set(event) {
					localStorage.setItem(`settings.videoAutoLoop`, event.target.checked)
					this.value = event.target.checked
				},
				ShowedCallback(inputElement) {
					inputElement.classList.add('toggleButton')
					inputElement.checked = this.value
				}
			}, videoAutoPlay: {
				name: '動画の自動再生',
				description: '動画、音声を自動的に再生します(音量注意)',
				value: util.StringToBool(localStorage.getItem('settings.videoAutoPlay')) ?? false,
				inputType: 'checkbox',
				Set(event) {
					localStorage.setItem(`settings.videoAutoPlay`, event.target.checked)
					this.value = event.target.checked
				},
				ShowedCallback(inputElement) {
					inputElement.classList.add('toggleButton')
					inputElement.checked = this.value
				}
			}
		}

		const fileViewers = [
			{
				name: '音楽プレイヤー',
				description: '音楽を再生します',
				viewer: AudioViewer
			}, {
				name: '動画プレイヤー',
				description: '動画を再生します',
				viewer: VideoViewer
			}, {
				name: 'コードビューワー',
				description: '一般的なプログラムコードをシンタックスハイライトして表示します',
				viewer: CodeViewer
			}, {
				name: 'コードエディタ',
				description: 'Monaco Editor',
				viewer: CodeEditor
			}, {
				name: '画像ビューワー',
				description: '画像を表示します',
				viewer: ImageViewer
			}, {
				name: 'MarkDown ビューワー',
				description: 'テキストをマークダウンとして表示します',
				viewer: MarkDownViewer
			}, {
				name: 'HTML ビューワー',
				description: 'テキストをHTMLとして表示します',
				viewer: HTMLViewer
			}, {
				name: 'PDFビューワー',
				description: 'PDFを表示します',
				viewer: PDFViewer
			}, {
				name: '既定',
				description: 'ブラウザ標準を利用します',
				viewer: DefaultViewer
			},
		]

		const filetypes = {
			folder: {
				iconPath: '/src/ico/folder.svg',
			}, default: {
				fileViewer: DefaultViewer,
				iconPath: '/src/ico/file.svg',
			}, audio: {
				fileViewer: AudioViewer,
				iconPath: '/src/ico/audiofile.svg',
			}, video: {
				fileViewer: VideoViewer,
				filePreviewer: VideoPreviewer,
				iconPath: '/src/ico/movie.svg',
			}, pdf: {
				fileViewer: PDFViewer,
				filePreviewer: PDFPreviewer,
				iconPath: '/src/ico/textfile.svg',
			}, img: {
				fileViewer: ImageViewer,
				filePreviewer: ImagePreviewer,
				iconPath: '/src/ico/image.svg',
			}, markdown: {
				fileViewer: MarkDownViewer,
				iconPath: '/src/ico/textfile.svg',
			}, code: {
				fileViewer: CodeEditor,
				iconPath: '/src/ico/textfile.svg',
			}, zip: {
				iconPath: '/src/ico/zipfile.svg',
			}, presentation: {
				iconPath: '/src/ico/presentationfile.svg'
			}, exe: {
				iconPath: '/src/ico/commandline.svg'
			}
		}

		const extensions = {
			//拡張子なし
			['']: {
				...filetypes.default,
				description: 'ファイル',
				openable: false,
			},
			// 音声ファイル
			mp3: {
				...filetypes.audio,
				description: 'MPEG Audio Layer-3 音声ファイル',
				openable: true,
			}, ogg: {
				...filetypes.audio,
				description: 'ogg 音声ファイル',
				openable: true,
			}, oga: {
				...filetypes.audio,
				description: 'oga 音声ファイル',
				openable: false,
			}, wav: {
				...filetypes.audio,
				description: 'wav 音声ファイル',
				openable: true,
			}, wma: {
				...filetypes.audio,
				description: 'Windows Media Audio 音声ファイル',
				openable: false,
			}, m4a: {
				...filetypes.audio,
				description: 'MPEG-4 音声ファイル',
				openable: true,
			}, mka: {
				...filetypes.audio,
				description: 'Matroska 音声ファイル',
				openable: true,
			},
			// 動画ファイル
			mp4: {
				...filetypes.video,
				description: 'MPEG-4 動画ファイル',
				openable: true,
			}, mpg: {
				...filetypes.video,
				description: 'MPEG-1,2 動画ファイル',
				openable: true,
			}, mpeg: {
				...filetypes.video,
				description: 'MPEG-1,2 動画ファイル',
				openable: true,
			}, avi: {
				...filetypes.video,
				description: 'Audio Video Interleave 動画ファイル',
				openable: true,
			}, wmv: {
				...filetypes.video,
				description: 'Windows Media Video 動画ファイル',
				openable: false,
			}, ogv: {
				...filetypes.video,
				description: 'oga 動画ファイル',
				openable: true,
			}, ts: {
				...filetypes.video,
				description: 'ts 動画ファイル',
				openable: true,
			}, webm: {
				...filetypes.video,
				description: 'webm 動画ファイル',
				openable: true,
			}, mkv: {
				...filetypes.video,
				description: 'Matroska 動画ファイル',
				openable: true,
			}, mov: {
				...filetypes.video,
				description: 'QuickTime 動画ファイル',
				openable: true,
			}, m2ts: {
				...filetypes.video,
				description: 'QuickTime 動画ファイル',
				openable: true,
			}, mts: {
				...filetypes.video,
				description: 'QuickTime 動画ファイル',
				openable: true,
			}, m2t: {
				...filetypes.video,
				description: 'QuickTime 動画ファイル',
				openable: true,
			},
			// 画像ファイル
			jpg: {
				...filetypes.img,
				description: 'JPEG 非可逆圧縮画像ファイル',
				openable: true,
			}, jpeg: {
				...filetypes.img,
				description: 'JPEG 非可逆圧縮画像ファイル',
				openable: true,
			}, jp2: {
				...filetypes.img,
				description: 'JPEG 2000 ファイル',
				openable: false,
			}, j2k: {
				...filetypes.img,
				description: 'JPEG 2000 ファイル',
				openable: false,
			}, hdp: {
				...filetypes.img,
				description: 'HD Photo ファイル',
				openable: false,
			}, wdp: {
				...filetypes.img,
				description: 'Windows Media Photo ファイル',
				openable: false,
			}, jxr: {
				...filetypes.img,
				description: 'JPEG XR ファイル',
				openable: false,
			}, png: {
				...filetypes.img,
				description: 'Portable Network Graphics 可逆圧縮画像ファイル',
				openable: true,
			}, apng: {
				...filetypes.img,
				description: 'Portable Network Graphics アニメーション画像ファイル',
				openable: true,
			}, gif: {
				...filetypes.img,
				description: 'Graphics Interchange Format アニメーション画像ファイル',
				openable: true,
			}, tiff: {
				...filetypes.img,
				description: 'Tagged Image File Format 画像ファイル',
				openable: true,
			}, tif: {
				...filetypes.img,
				description: 'Tagged Image File Format 画像ファイル',
				openable: true,
			}, gif: {
				...filetypes.img,
				description: 'windowsビットマップ 画像ファイル',
				openable: true,
			}, gif: {
				...filetypes.img,
				description: 'ベクター形式 画像ファイル',
				openable: true,
			}, webp: {
				...filetypes.img,
				description: 'WebP 画像ファイル',
				openable: true,
			}, avif: {
				...filetypes.img,
				description: 'AV1 画像ファイル',
				openable: true,
			}, heic: {
				...filetypes.img,
				description: 'High Efficiency 画像ファイル',
				openable: true,
			}, svg: {
				...filetypes.img,
				description: 'ベクター画像ファイル',
				openable: true,
			},
			// PDF
			pdf: {
				...filetypes.pdf,
				description: 'PDF ドキュメント',
				openable: false,
			},
			// 圧縮ファイル
			['7z']: {
				...filetypes.zip,
				description: '7-Zip 圧縮ファイル',
				openable: false,
			}, zip: {
				...filetypes.zip,
				description: 'ZIP 圧縮ファイル',
				openable: false,
			}, gz: {
				...filetypes.zip,
				description: 'gzip 圧縮ファイル',
				openable: false,
			}, gzip: {
				...filetypes.zip,
				description: 'gzip 圧縮ファイル',
				openable: false,
			}, rar: {
				...filetypes.zip,
				description: 'rar 圧縮ファイル',
				openable: false,
			}, bz2: {
				...filetypes.zip,
				description: 'bzip2 圧縮ファイル',
				openable: false,
			}, bzip2: {
				...filetypes.zip,
				description: 'bzip2 圧縮ファイル',
				openable: false,
			}, lzh: {
				...filetypes.zip,
				description: 'lzh 圧縮ファイル',
				openable: false,
			}, cab: {
				...filetypes.zip,
				description: 'キャビネット 圧縮ファイル',
				openable: false,
			}, sit: {
				...filetypes.zip,
				description: 'sit 圧縮ファイル',
				openable: false,
			},
			//プレゼンテーションファイル
			pptx: {
				...filetypes.presentation,
				description: 'PowerPoint プレゼンテーションファイル',
				openable: false,
			}, pptm: {
				...filetypes.presentation,
				description: 'PowerPoint マクロ有効プレゼンテーションファイル',
				openable: false,
			}, ppt: {
				...filetypes.presentation,
				description: 'PowerPoint 97-2003 プレゼンテーションファイル',
				openable: false,
			}, key: {
				...filetypes.presentation,
				description: 'Keynote プレゼンテーションファイル',
				openable: false,
			}, potx: {
				...filetypes.presentation,
				description: 'PowerPoint テンプレートファイル',
				openable: false,
			},
			// ソースコード
			md: { ...filetypes.markdown, description: 'MarkDown ソースファイル', openable: true },
			txt: { ...filetypes.code, description: 'テキストファイル', openable: true },
			js: { ...filetypes.code, description: 'JavaScript ソースファイル', openable: true },
			jsx: { ...filetypes.code, description: 'JavaScript ソースファイル', openable: true },
			tsx: { ...filetypes.code, description: 'JavaScript ソースファイル', openable: true },
			html: { ...filetypes.code, fileViewer: HTMLViewer, description: 'HTML ソースファイル', openable: true },
			shtml: { ...filetypes.code, description: 'SSI HTML ソースファイル', openable: true },
			aspx: { ...filetypes.code, description: 'Active Server Pages ソースファイル', openable: true },
			htm: { ...filetypes.code, description: 'HTML ソースファイル', openable: true },
			xml: { ...filetypes.code, description: 'XML ソースファイル', openable: true },
			css: { ...filetypes.code, description: 'カスケードスタイルシート ソースファイル', openable: true },
			php: { ...filetypes.code, description: 'PHP ソースファイル', openable: true },
			yaml: { ...filetypes.code, description: 'YAML ソースファイル', openable: true },
			py: { ...filetypes.code, description: 'Python ソースファイル', openable: true },
			wasm: { ...filetypes.code, description: 'WebAssembly ソースファイル', openable: true },
			json: { ...filetypes.code, description: 'JSON ソースファイル', openable: true },
			json5: { ...filetypes.code, description: 'JSON(5) ソースファイル', openable: true },
			c: { ...filetypes.code, description: 'C ソースファイル', openable: true },
			cc: { ...filetypes.code, description: 'C++ ソースファイル', openable: true },
			cp: { ...filetypes.code, description: 'Apple Xcode C++ ソースファイル', openable: true },
			cpp: { ...filetypes.code, description: 'C++ ソースファイル', openable: true },
			cxx: { ...filetypes.code, description: 'C++ ソースファイル', openable: true },
			rb: { ...filetypes.code, description: 'Ruby ソースファイル', openable: true },
			swift: { ...filetypes.code, description: 'Swift ソースファイル', openable: true },
			h: { ...filetypes.code, description: 'C,C++(ヘッダー) ソースファイル', openable: true },
			graphql: { ...filetypes.code, description: 'GraphQL ソースファイル', openable: true },
			gql: { ...filetypes.code, description: 'GraphQL ソースファイル', openable: true },
			rs: { ...filetypes.code, description: 'Rust ソースファイル', openable: true },
			go: { ...filetypes.code, description: 'Go ソースファイル', openable: true },
			java: { ...filetypes.code, description: 'Java ソースファイル', openable: true },
			sql: { ...filetypes.code, description: 'sql ソースファイル', openable: true },
			pl: { ...filetypes.code, description: 'Perl ソースファイル', openable: true },
			bat: { ...filetypes.code, description: 'Windows バッチファイル', openable: true },
			ps1: { ...filetypes.code, description: 'Windows PowerShell バッチファイル', openable: true },
			sh: { ...filetypes.code, description: 'Unix シェル', openable: true },
			toml: { ...filetypes.code, description: 'TOML 設定ファイル', openable: true },
			cfg: { ...filetypes.code, description: '設定ファイル', openable: true },
			conf: { ...filetypes.code, description: '設定ファイル', openable: true },
			conf: { ...filetypes.code, description: '設定ファイル', openable: true },
			ini: { ...filetypes.code, description: '構成ファイル', openable: true },
			inf: { ...filetypes.code, description: 'システム定義ファイル', openable: true },
			pif: { ...filetypes.code, description: 'MS-DOS プログラムのショートカット', openable: true },
			//実行ファイル
			exe: { ...filetypes.exe, description: 'windows 実行ファイル', openable: false },
			com: { ...filetypes.exe, description: 'MS-DOS 実行ファイル', openable: false },
			app: { ...filetypes.exe, description: 'Mac OS X 実行ファイル', openable: false },
			//ファイル置き場独自ファイル
			['fa-exe']: {
				...filetypes.exe,
				fileViewer: FileappExecuter,
				filePreviewer: null,
				description: 'ファイル置き場実行ファイル',
				openable: false
			},
		}

		const sidebar = {
			icons: [
				{
					iconPath: '/src/ico/folder.svg',
					text: 'ファイル',
					onClick: () => document.querySelector("div.directoryView").scrollIntoView()
				}, {
					iconPath: '/src/ico/arrow_up_tray.svg',
					text: '追加したファイル',
					onClick: () => document.querySelector("div.addedFilesView").scrollIntoView(),
					DetailElementHandle(element) {

					}
				}, {
					iconPath: '/src/ico/star.svg',
					text: 'お気に入り',
					onClick: () => document.querySelector("div.favoriteFilesView").scrollIntoView(),
					DetailElementHandle(element) {
						const Update = () => {
							element.innerHTML = ''
							FavoriteManager.list.forEach(fileName => {
								const fileManager = new FileManager(fileName)
								const fileUI = new FileUI(decodeURIComponent(fileName))
								const fileElement = document.createElement('button')
								fileElement.classList.add('sideButton')
								fileElement.addEventListener('click', () => {
									fileUI.Open()
								})
								fileElement.addEventListener('contextmenu', e => {
									e.preventDefault()
									fileUI.Context()
								})

								const textIconRapper = document.createElement('div')
								textIconRapper.classList.add('sideButton_textIconRapper')
								fileElement.appendChild(textIconRapper)

								const icon = document.createElement('div')
								icon.classList.add('sideButton_icon')
								icon.style.webkitMaskImage = `url(${fileUI.iconPath})`
								icon.style.maskImage = `url(${fileUI.iconPath})`
								textIconRapper.appendChild(icon)

								const text = document.createElement('span')
								text.classList.add('sideButton_text')
								text.innerText = decodeURIComponent(fileManager.filePath.name)
								textIconRapper.appendChild(text)
								element.appendChild(fileElement)
							})
						}
						Update()
						FavoriteManager.list = util.ReturnWatchArray(FavoriteManager.list, Update)
					}
				},
			],
			Open() {
				document.querySelector('.sidebar').style.width = document.querySelector('.sidebar').dataset.width + 'px'
				document.querySelector('.sidebar').dataset.state = 'open'
			},
			Close() {
				document.querySelector('.sidebar').style.width = '56px'
				document.querySelector('.sidebar').dataset.state = 'close'
			},
			Init() {
				sidebar.icons.forEach(iconSetting => {
					const button = document.createElement('button')
					button.classList.add('sideButton')
					button.addEventListener('click', iconSetting.onClick)
					if (iconSetting.spInvisible) {
						button.classList.add('sp-invisible')
					}

					const textIconRapper = document.createElement('div')
					textIconRapper.classList.add('sideButton_textIconRapper')
					button.appendChild(textIconRapper)

					const icon = document.createElement('div')
					icon.classList.add('sideButton_icon')
					icon.style.webkitMaskImage = `url(${iconSetting.iconPath})`
					icon.style.maskImage = `url(${iconSetting.iconPath})`
					icon.title = iconSetting.text
					textIconRapper.appendChild(icon)

					const text = document.createElement('span')
					text.classList.add('sideButton_text')
					text.innerText = iconSetting.text
					textIconRapper.appendChild(text)

					document.querySelector(`.sidebar_icons`).appendChild(button)

					if (iconSetting.DetailElementHandle) {
						const expandButton = document.createElement('button')
						expandButton.classList.add('sideButton_icon', 'sideButton_expandButton')
						expandButton.style.webkitMaskImage = `url(/src/ico/chevron-up.svg)`
						expandButton.style.maskImage = `url(/src/ico/chevron-up.svg)`
						expandButton.style.rotate = '0deg'
						button.appendChild(expandButton)

						const detailElement = document.createElement('div')
						detailElement.classList.add('sideButton_detail')
						document.querySelector(`.sidebar_icons`).appendChild(detailElement)

						let isExpanded = true
						expandButton.addEventListener('click', e => {
							e.stopPropagation()
							if (isExpanded === true) {
								detailElement.style.display = 'none'
								expandButton.style.rotate = '180deg'
								isExpanded = false
							} else if (isExpanded === false) {
								detailElement.style.display = null
								detailElement.animate(
									[
										{ opacity: 0, transform: 'translateY(-20px)' },
										{ opacity: 1, transform: 'translateY(0px)' }
									], {
									duration: 200, //再生時間（ミリ秒）
									easing: 'cubic-bezier(0.25, 1, 0.5, 1)', //イージング
								})
								expandButton.style.rotate = '0deg'
								isExpanded = true
							}
						})

						iconSetting.DetailElementHandle(detailElement)
					}
				})
			}
		}

		const ChangeTitle = name => {
			document.title = name ? `${name} | ファイル置き場` : 'ファイル置き場'
		}

		const fileUpdateIntervalHandle = () => {
			if ((document.visibilityState === 'visible' || userSettings.forcedFileUpdate.value) === false) return
			mainDirectoryViewer.UpdateFiles()
		}

		let fileUpdateInterval = setInterval(fileUpdateIntervalHandle, userSettings.updateInterval.value)

		const theme = {
			Light: () => {
				document.body.dataset.theme = 'light'
				util.UpdateThemeColor()
				localStorage.setItem('theme', 'light')
			},
			Dark: () => {
				document.body.dataset.theme = 'dark'
				util.UpdateThemeColor()
				localStorage.setItem('theme', 'dark')
			},
			System: () => {
				document.body.dataset.theme = 'system'
				util.UpdateThemeColor()
				localStorage.setItem('theme', 'system')
			}
		}

		const SetBackgroundImage = url => {
			if (url) {
				document.body.classList.add('using-background-image')
				util.Css(`body.using-background-image .body::before {background-image:url("/api/backgrounds/${url}")}`)
				localStorage.setItem('background-image', url)
			}
			else {
				document.body.classList.remove('using-background-image')
				localStorage.removeItem('background-image')
			}
		}

		switch (localStorage.getItem('theme')) {
			case 'light':
				theme.Light()
				break;
			case 'dark':
				theme.Dark()
				break;
			case 'system':
				theme.System()
				break
			default:
				theme.System()
				break;
		}

		if (userSettings.deepDarkMode.value) {
			document.body.classList.add('deep-dark')
		}

		SetBackgroundImage(localStorage.getItem('background-image'))

		document.addEventListener('DOMContentLoaded', async () => {
			sidebar.Init()
			const sidebarElement = document.querySelector('.sidebar')
			const sidebarDragArea = document.querySelector('.sidebar_dragArea')
			const ButtonRapper = document.querySelector('.sidebar_toggle')
			const sidebarWidth = localStorage.getItem('sidebar.width')

			if (sidebarWidth) {
				sidebarElement.dataset.width = sidebarWidth
			}

			sidebarDragArea.addEventListener('mousedown', (event) => {
				document.body.style.userSelect = 'none'
				sidebarElement.style.transition = 'none'

				const startPosition = mousePosition.x
				const startWidth = sidebarElement.offsetWidth

				if (startWidth > document.body.offsetWidth / 2) {
					sidebarElement.style.width = document.body.offsetWidth / 2 + 'px'
				}

				const mousemoveHandle = event => {
					const offset = mousePosition.x - startPosition
					const width = startWidth + offset
					if (width > document.body.offsetWidth / 2) return
					sidebarElement.style.width = width + 'px'
					sidebarElement.dataset.width = width
				}

				document.addEventListener('mousemove', mousemoveHandle);
				document.addEventListener('mouseup', event => {
					document.body.style.userSelect = null
					sidebarElement.style.transition = null
					localStorage.setItem('sidebar.width', sidebarElement.dataset.width)
					document.removeEventListener('mousemove', mousemoveHandle);
				}, { once: true })
			})
			sidebarDragArea.addEventListener('dblclick', (event) => {
				sidebarElement.style.width = '250px'
				sidebarElement.dataset.width = 250
				localStorage.setItem('sidebar.width', null)
			})
			document.querySelector('#sidebar_control_button').addEventListener('click', () => {
				document.querySelector('.sidebar').dataset.state === 'open' ? sidebar.Close() : sidebar.Open()
			})
			document.querySelector('#setting_button').addEventListener('click', e => {
				const rect = e.target.getBoundingClientRect()
				new ContextMenu({
					menuList: [
						{
							text: (() => { return IS_BETA ? '通常版に切り替え' : 'ベータ版に切り替え' })(),
							onClick: () => {
								if (IS_BETA) {
									const url = new URL(location.href)
									url.searchParams.delete('ver')
									location.replace(url.href)
								} else {
									const url = new URL(location.href)
									url.searchParams.set('ver', 'beta')
									location.replace(url.href)
								}
							},
						}, {
							text: "ページの再読み込み",
							onClick: () => location.reload(),
							icon: '/src/ico/reload.svg',
						}, {
							text: "インストール",
							onClick: () => {
								window?.installPromptEvent?.prompt() ?? new Toast('エラーが発生しました', { color: 'red' }).Show()
							},
							icon: '/src/ico/arrow-down-tray.svg',
							disable: !(window?.installPromptEvent?.prompt)
						}, {
							type: 'line'
						}, {
							text: "テーマ",
							submenu: [
								{
									text: "ライトテーマ",
									onClick: theme.Light,
									icon: '/src/ico/sun.svg'
								}, {
									text: "ダークテーマ",
									onClick: theme.Dark,
									icon: '/src/ico/moon.svg'
								}, {
									text: "システムのテーマ",
									onClick: theme.System
								},
							],
							icon: '/src/ico/chevron-right.svg'
						}, {
							type: 'line'
						}, {
							text: "設定",
							onClick: modals.settings.Open,
							icon: '/src/ico/setting.svg'
						}, {
							text: "背景画像",
							onClick: modals.backgroundSelect.Open,
							icon: '/src/ico/image.svg'
						}
					]
				}).Show().SetPosition(rect.right, rect.bottom)
			})
			if (IS_BETA) {
				document.querySelector('.version').style.display = null
			}
			util.UpdateThemeColor()
			// SuperSecret!
			document.querySelector('.appTitle').addEventListener('click', () => {
				const secretElement = document.querySelector('.appTitle')
				if ((performance.now() - Number(secretElement.dataset.clickTimestamp)) < 5000) {
					secretElement.dataset.clickCount = Number(secretElement.dataset.clickCount) + 1
					switch (secretElement.dataset.clickCount) {
						case '19':
							util.VibrateScreen(0.1, 3)
							break;
						case '20':
							util.VibrateScreen(0.2, 3)
							break;
						case '21':
							util.VibrateScreen(0.3, 5)
							break;
						case '22':
							util.VibrateScreen(0.8, 5)
							break;
						case '23':
							util.VibrateScreen(3, 8)
							new ContextMenu({
								menuList: [
									{
										text: 'Dinnerbone',
										onClick: () => {
											document.body.style.rotate = '180deg'
										},
									}, {
										text: '斜め',
										onClick: () => {
											document.body.style.rotate = '1deg'
										},
									}, {
										text: '一回転',
										onClick: () => {
											document.body.animate(
												[
													{ rotate: '0deg' },
													{ rotate: '360deg' }
												], {
												duration: 4000, //再生時間（ミリ秒）
												easing: 'ease-in-out', //イージング
											})
										},
									}, {
										text: '応答なし',
										onClick: () => {
											window.addEventListener('keydown', e => e.preventDefault())
											window.addEventListener('contextmenu', e => e.preventDefault())
											const rapper = document.createElement('div')
											rapper.style.cursor = 'wait'
											rapper.style.width = '100dvw'
											rapper.style.height = '100dvh'
											rapper.style.zIndex = '999999'
											rapper.style.position = 'fixed'
											rapper.style.top = '0'
											document.body.appendChild(rapper)
										},
									}, {
										text: 'AAAAA',
										onClick: () => {
											util.VibrateScreen(0.5, Infinity)
										},
									}, {
										text: `I'm Feeling Lucky`,
										onClick: () => {
											new FileUI(util.RandomFromArray(FavoriteManager.list)).Open()
										},
									}, {
										text: `ランダムフォント`,
										disable: !('queryLocalFonts' in window),
										onClick: async () => {
											const fonts = await queryLocalFonts()
											document.body.style.fontFamily = util.RandomFromArray(fonts).family
										},
									}, {
										text: `I give up CSS`,
										onClick: async () => {
											document.querySelectorAll('style').forEach(element => element.remove())
										},
									}, {
										text: `/api/files/`,
										onClick: async () => {
											location.href = `${BASE_URL}api/files/`
										},
									},
								]
							}).Show()
							secretElement.dataset.clickCount = '0'
							break;
						default:
							break;
					}
				} else {
					secretElement.dataset.clickCount = 0
				}
				secretElement.dataset.clickTimestamp = performance.now().toFixed()
			})
			if (!localStorage.getItem('fileapp.player.fileVolume')) {
				localStorage.setItem('fileapp.player.fileVolume', JSON.stringify({}))
			}
		})

		window.addEventListener('beforeinstallprompt', (event) => {
			window.installPromptEvent = event;
		});

		window.addEventListener('load', async () => {
			window.loaded = true
			const url = new URL(location.href)
			console.timeEnd('load')
			if (url.searchParams.get('rel') === 'protocolhandler') {
				location.replace(BASE_URL + new URL(decodeURIComponent(url.searchParams.get('target'))).pathname)
			}
			if (filePath.GetName(PATH_PARAMETER)) {
				const targetFile = new FileManager(PATH_PARAMETER)
				await targetFile.IsExits() ?
					new FileUI(PATH_PARAMETER).Open() :
					new Toast('指定されたファイルURLを開けませんでした', { color: 'red' }).Show()
			}
		})

		window.addEventListener('focus', () => {
			document.body.classList.remove('blur');
			util.UpdateThemeColor()
		});

		window.addEventListener('blur', () => {
			document.body.classList.add('blur');
			util.UpdateThemeColor()
		});

		document.addEventListener('fullscreenchange', () => {
			if (document.fullscreenElement) {
				document.body.classList.add('fullscreen');
			} else {
				document.body.classList.remove('fullscreen');
			}
		});

		if ('serviceWorker' in navigator) {
			navigator.serviceWorker.register('/src/sw.js', { scope: BASE_PATH }).then((registration) => {
				// 登録成功
				console.info('ServiceWorker の登録に成功しました。スコープ: ', registration.scope);
			}).catch(function (err) {
				// 登録失敗
				console.info('ServiceWorker の登録に失敗しました。', err);
			});
		}

	</script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js" defer
		fetchpriority="low"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"
		defer fetchpriority="low"></script>
	<script src='https://cdn.jsdelivr.net/gh/rsms/markdown-wasm@v1.1.2/dist/markdown.js' defer
		fetchpriority="low"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.7.107/pdf.min.js" defer fetchpriority="low"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.40.0/min/vs/loader.min.js" defer
		fetchpriority="low"></script>
	<script type="text/javascript" src="/src/qrcode.js" defer fetchpriority="low"></script>
	<link rel="stylesheet" href="/src/highlight/styles/monokai-sublime.min.css" media="print" onload="this.media='all'"
		fetchpriority="low">
	<link rel="preload" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap" as="style"
		onload="this.onload=null;this.rel='stylesheet'" fetchpriority="low" />
	<link rel="preload" href="https://cdn.jsdelivr.net/npm/monaco-editor@0.40.0/min/vs/editor/editor.main.min.css"
		as="style" onload="this.onload=null;this.rel='stylesheet'" fetchpriority="low">
	<link rel="prefetch" href="/src/ico/dragfileico.png">
</body>

</html>
